module brunerie2 where

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> hcomp A (p @ i) [ (i =0) -> <j> a, (i = 1) -> q ]

compInvPath (A : U) (a b : A) (p : Path A a b) :
  Path (Path A b b) (compPath A b a b (<i> p @ -i) p)  (<_> b) =
   <j i> hcomp A (p @ -i \/ j)
                 [ (i = 0) -> <_> b
                 , (j = 1) -> <_> b
                 , (i = 1) -> <k> p @ j \/ k ]

data bool = false | true
data nat = zero | suc (n : nat)

idfun (A : U) (a : A) : A = a

pred : nat -> nat = split
  zero -> zero
  suc n -> n

{- Z is represented as:

  +2 = pos (suc (suc zero))
  +1 = pos (suc zero)
   0 = pos zero
  -1 = neg zero
  -2 = neg (suc zero)

-}
data Z = pos (n : nat) | neg (n : nat)

twoZ : Z = pos (suc (suc zero))
oneZ : Z = pos (suc zero)
zeroZ : Z = pos zero
moneZ : Z = neg zero
mtwoZ : Z = neg (suc zero)

data S1 = base1
        | loop1 <i> [ (i=0) -> base1
                    , (i=1) -> base1 ]

data S2 = base2
        | loop2 <i j> [ (i=0) -> base2
                      , (i=1) -> base2
                      , (j=0) -> base2
                      , (j=1) -> base2]

data S3 = base3
        | loop3 <i j k> [ (i=0) -> base3
                        , (i=1) -> base3
                        , (j=0) -> base3
                        , (j=1) -> base3
                        , (k=0) -> base3
                        , (k=1) -> base3]

loopS1 : U = Path S1 base1 base1
loop : loopS1 = <i> loop1{S1} @ i

-- Pointed types
ptType : U = (A : U) * A
pt (A : ptType) : A.1 = A.2

boolpt : ptType = (bool,true)
S1pt : ptType = (S1,base1)
S2pt : ptType = (S2,base2)
S3pt : ptType = (S3,base3)

ptMap (A B : ptType) : U = (f : A.1 -> B.1) * (Path B.1 (f (pt A)) (pt B))

-- The first 3 loop spaces of a pointed type.
-- TODO: Maybe defined these by induction on n as in experiments/pointed.ctt?
Omega (A : ptType) : ptType = (Path A.1 (pt A) (pt A),<_> pt A)
Omega2 (A : ptType) : ptType = Omega (Omega A)
Omega3 (A : ptType) : ptType = Omega2 (Omega A)

kanOp (A : U) (a : A) (p : Path A a a) (b : A) (q : Path A a b) : Path A b b =
 <i> hcomp A (p @ i) [ (i = 0) -> q, (i = 1) -> q ]

kanOpRefl (A : U) (a b : A) (q : Path A a b) :
  Path (Path A b b) (kanOp A a (<i> a) b q) (<_> b) =
    <j i> hcomp A (q @ j) [ (i = 0) -> <k> q @ j \/ k
                          , (i = 1) -> <k> q @ j \/ k
                          , (j = 1) -> <k> b ]

mapOmega (A B : ptType) (f : ptMap A B) : ptMap (Omega A) (Omega B) = (g,pg)
  where
  g (p : (Omega A).1) : (Omega B).1 =
   kanOp B.1 (f.1 (pt A)) (<i>f.1 (p@i)) (pt B) f.2
  pg : Path (Omega B).1 (g (pt (Omega A))) (pt (Omega B)) =
    kanOpRefl B.1 (f.1 (pt A)) (pt B) f.2

mapOmega2 (A B : ptType) (f : ptMap A B) : ptMap (Omega2 A) (Omega2 B) =
  mapOmega (Omega A) (Omega B) (mapOmega A B f)

mapOmega3 (A B : ptType) (f : ptMap A B) : ptMap (Omega3 A) (Omega3 B) =
  mapOmega (Omega2 A) (Omega2 B) (mapOmega2 A B f)

-- Simplified mapOmega when the function is pointed by reflexivity
mapOmegaRefl (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega A).1) :
  (Omega (B, h (pt A))).1 = <i> h (p @ i)

mapOmegaRefl2 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega2 A).1) :
  (Omega2 (B, h (pt A))).1 = <i j> h (p @ i @ j)
  -- mapOmegaRefl (Omega A) (Omega (B,h (pt A))).1 (mapOmegaRefl A B h) p

mapOmegaRefl3 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega3 A).1) :
  (Omega3 (B, h (pt A))).1 = <i j k> h (p @ i @ j @ k)
  -- mapOmegaRefl2 (Omega A) (Omega (B,h (pt A))).1 (mapOmegaRefl A B h)


data join (A B : U) = inl (a : A)
                    | inr (b : B)
                    | push (a : A) (b : B) <i> [ (i = 0) -> inl a
                                               , (i = 1) -> inr b ]

pushP (A B : U) (a : A) (b : B) : Path (join A B) (inl a) (inr b) =
  <i> push {join A B} a b @ i

joinpt (A : ptType) (B : U) : ptType = (join A.1 B,inl (pt A))

-- Attempt to write e:

--         v
--    b0 -----> b1
--    |         |
--    |         |
-- r0 |         | r1
--    |         |
--    a0 -----> a1
--         u
Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (Path A (u @ i) (v @ i))) r0 r1

sq (A : U) (a b c : A) (p : Path A a b) (q : Path A c a) :
  Square A a b c a p q (<i> q @ -i) (<i> p @ -i) =
  <i j> hcomp A a [ (i = 0) -> <k> q @ -k \/ -j
                  , (i = 1) -> <k> p @ k /\ -j
                  , (j = 0) -> <k> p @ k /\ i
                  , (j = 1) -> <k> q @ -k \/ i ]


sq' (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) :
  Square A a b b c p q p q =
  <i j> hcomp A b [ (i = 0) -> <k> p @ j \/ -k
                  , (i = 1) -> <k> q @ j /\ k
                  , (j = 0) -> <k> p @ i \/ -k
                  , (j = 1) -> <k> q @ i /\ k ]

sqsq' (A : U) (a b : A) (p : Path A a b) :
  Path (Square A a b b a p (<i> p @ -i) p (<i> p @ -i))
       (sq' A a b a p (<i> p @ -i))
       (sq A a b b p (<i> p @ -i)) =
  <l i j> hcomp A (p @ -l)
                [ (i = 0) -> <k> p @ (-l /\ (-k \/ j)) \/ (k /\ j)
                , (i = 1) -> <k> p @ (-l /\ (-k \/ -j)) \/ (k /\ -j)
                , (j = 0) -> <k> p @ (-l /\ (-k \/ i)) \/ (k /\ i)
                , (j = 1) -> <k> p @ (-l /\ (-k \/ -i)) \/ (k /\ -i)
                ]

cubealpha' : PathP (<k> PathP (<i> Path (join S1 S1)
                                       (pushP S1 S1 (loop @ i) base1 @ k)
                                       (pushP S1 S1 base1 base1 @ -k))
                             (<l> sq' (join S1 S1) (inl base1) (inr base1) (inl base1)
                                                  (pushP S1 S1 base1 base1)
                                                  (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k)
                             (<l> sq' (join S1 S1) (inl base1) (inr base1) (inl base1)
                                                  (pushP S1 S1 base1 base1)
                                                  (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k))
                   (<i l> pushP S1 S1 (loop @ i) base1 @ l)
                   (<i l> pushP S1 S1 base1 base1 @ -l) =
  <k i l> sq' (join S1 S1)
              (inl (loop @ i)) (inr base1) (inl base1)
              (pushP S1 S1 (loop @ i) base1)
              (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k

cubealpha : PathP (<k> PathP (<i> Path (join S1 S1)
                                       (pushP S1 S1 (loop @ i) base1 @ k)
                                       (pushP S1 S1 base1 base1 @ -k))
                             (<l> sq (join S1 S1) (inl base1) (inr base1) (inr base1)
                                                  (pushP S1 S1 base1 base1)
                                                  (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k)
                             (<l> sq (join S1 S1) (inl base1) (inr base1) (inr base1)
                                                  (pushP S1 S1 base1 base1)
                                                  (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k))
                   (<i l> pushP S1 S1 (loop @ i) base1 @ l)
                   (<i l> pushP S1 S1 base1 base1 @ -l) =
  <k i l> hcomp (join S1 S1)
                (cubealpha' @ k @ i @ l)
                [ (k=0) -> <w> pushP S1 S1 (loop @ i) base1 @ l
                , (k=1) -> <w> pushP S1 S1 base1 base1 @ -l
                , (i=0) -> <w> sqsq' (join S1 S1) (inl base1) (inr base1) (pushP S1 S1 base1 base1) @ w @ k @ l
                , (i=1) -> <w> sqsq' (join S1 S1) (inl base1) (inr base1) (pushP S1 S1 base1 base1) @ w @ k @ l
                , (l=0) -> <w> pushP S1 S1 (loop @ i) base1 @ k
                , (l=1) -> <w> pushP S1 S1 base1 base1 @ -k
                ]

cubebeta : PathP (<k> PathP (<j> Path (join S1 S1)
                                      (pushP S1 S1 base1 (loop @ j) @ k)
                                      (pushP S1 S1 base1 base1 @ -k))
                            (<l> sq (join S1 S1) (inl base1) (inr base1) (inr base1)
                                                 (pushP S1 S1 base1 base1)
                                                 (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k)
                            (<l> sq (join S1 S1) (inl base1) (inr base1) (inr base1)
                                                 (pushP S1 S1 base1 base1)
                                                 (<w> pushP S1 S1 base1 base1 @ -w) @ l @ k))
                   (<j l> pushP S1 S1 base1 base1 @ l)
                   (<j l> pushP S1 S1 base1 (loop @ j) @ -l) =
  <k j l> sq (join S1 S1)
             (inl base1) (inr (loop @ j)) (inr base1)
             (pushP S1 S1 base1 (loop @ j))
             (<w> pushP S1 S1 base1 base1 @ -w) @ k @ l


cubestep1 : PathP (<k> Path (Path (join S1 S1)
                                  (pushP S1 S1 base1 base1 @ -k)
                                  (pushP S1 S1 base1 base1 @ -k))
                      (<_> pushP S1 S1 base1 base1 @ -k)
                      (<_> pushP S1 S1 base1 base1 @ -k))
                  (<_ _> inr base1)
                  (<_ _> inl base1) =
  <k j i> hcomp (join S1 S1)
                (pushP S1 S1 (loop @ i) (loop @ j) @ k)
                [ (i=0) -> cubebeta  @ k @ j
                , (i=1) -> cubebeta  @ k @ j
                , (j=0) -> cubealpha @ k @ i
                , (j=1) -> cubealpha @ k @ i
                , (k=0) -> <w> pushP S1 S1 (loop @ i) base1 @ w
                , (k=1) -> <w> pushP S1 S1 base1 (loop @ j) @ -w
                ]

goalcube : Path (Path (Path (join S1 S1)
                            (inl base1) (inl base1))
                      (<_> inl base1) (<_> inl base1))
                (<_ _> inl base1) (<_ _> inl base1) =
  <k j i> hcomp (join S1 S1)
                (cubestep1 @ k @ j @ i)
                [ (k=0) -> <l> pushP S1 S1 base1 base1 @ -l
                , (k=1) -> <l> inl base1
                , (j=0) -> <l> pushP S1 S1 base1 base1 @ -k /\ -l
                , (j=1) -> <l> pushP S1 S1 base1 base1 @ -k /\ -l
                , (i=0) -> <l> pushP S1 S1 base1 base1 @ -k /\ -l
                , (i=1) -> <l> pushP S1 S1 base1 base1 @ -k /\ -l
                ]


-- Alternative definition of goalcube using an equality in the
-- universe. This seems to give a simpler test0To4!

-- The first type:
T1 : U = PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl (loop @ i)) (inr (loop @ j)))
                          (<j> pushP S1 S1 (loop @ i) base1 @ j)
                          (<j> pushP S1 S1 (loop @ i) base1 @ j))
               (<i j> pushP S1 S1 base1 (loop @ i) @ j)
               (<i j> pushP S1 S1 base1 (loop @ i) @ j)

-- The second type without loop:
T2 : U = PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl base1) (inr base1))
                          (<j> pushP S1 S1 base1 base1 @ j)
                          (<j> pushP S1 S1 base1 base1 @ j))
               (<i j> pushP S1 S1 base1 base1 @ j)
               (<i j> pushP S1 S1 base1 base1 @ j)

-- Direct equality in the universe:
T12 : Path U T1 T2 = <k>
         PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl (loop @ i /\ -k)) (inr (loop @ j /\ -k)))
                          (<j> pushP S1 S1 (loop @ i /\ -k) base1 @ j)
                          (<j> pushP S1 S1 (loop @ i /\ -k) (loop @ -k) @ j))
               (<i j> pushP S1 S1 base1 (loop @ i /\ -k) @ j)
               (<i j> pushP S1 S1 (loop @ -k) (loop @ i /\ -k) @ j)

-- Let cubicaltt do the job for us:
cubestep1' : T2 = transGen T12 0 (<i j k> pushP S1 S1 (loop @ i) (loop @ j) @ k)

-- Finish it up by hand:
goalcube' : Path (Path (Path (join S1 S1)
                            (inl base1) (inl base1))
                      (<_> inl base1) (<_> inl base1))
                (<_ _> inl base1) (<_ _> inl base1) =
  <i j k> hcomp (join S1 S1)
                (cubestep1' @ i @ j @ k)
                [ (k=0) -> <l> inl base1
                , (k=1) -> <l> pushP S1 S1 base1 base1 @ -l
                , (j=0) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (j=1) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (i=0) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (i=1) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                ]


-- Inspired by Evan's redtt code
goalcube'' : Path (Path (Path (join S1 S1)
                            (inl base1) (inl base1))
                      (<_> inl base1) (<_> inl base1))
                (<_ _> inl base1) (<_ _> inl base1) =
  <i j k> hcomp (join S1 S1)
                (pushP S1 S1 (loop @ j) (loop @ k) @ i)
                [
                  (i=0) -> facek01 @ 1 @ j
                , (i=1) -> <m> pushP S1 S1 base1 (loop @ k) @ -m
                , (j=0) -> <m> pushP S1 S1 base1 (loop @ k) @ i /\ -m
                , (j=1) -> <m> pushP S1 S1 base1 (loop @ k) @ i /\ -m
                , (k=0) -> facek01 @ -i @ j
                , (k=1) -> facek01 @ -i @ j
                ]

  where
  facek01 : PathP (<i> PathP (<j> Path (join S1 S1)
                                       (pushP S1 S1 (loop @ j) base1 @ -i)
                                       (inl base1))
                             (<k> pushP S1 S1 base1 base1 @ -i /\ -k)
                             (<k> pushP S1 S1 base1 base1 @ -i /\ -k))
                  (<j k> pushP S1 S1 base1 base1 @ -k)
                  (<j k> hcomp (join S1 S1)
                               (pushP S1 S1 base1 base1 @ -k)
                               [ (j=0) -> <i> pushP S1 S1 base1 base1 @ -i /\ -k
                               , (j=1) -> <i> pushP S1 S1 base1 base1 @ -i /\ -k
                               , (k=0) -> <i> pushP S1 S1 (loop @ j) base1 @ -i
                               , (k=1) -> <_> inl base1
                               ]) =
   <i j k> hfill (join S1 S1)
                 (pushP S1 S1 base1 base1 @ -k)
                 [ (j=0) -> <i> pushP S1 S1 base1 base1 @ -i /\ -k
                 , (j=1) -> <i> pushP S1 S1 base1 base1 @ -i /\ -k
                 , (k=0) -> <i> pushP S1 S1 (loop @ j) base1 @ -i
                 , (k=1) -> <_> inl base1
                 ] @ i

-- normal form of Evan's cube
ngoalcube'' : Path (Path (Path (join S1 S1)
                            (inl base1) (inl base1))
                      (<_> inl base1) (<_> inl base1))
                (<_ _> inl base1) (<_ _> inl base1) =
  <i j k> hcomp (join S1 S1)
              (pushP S1 S1 (loop @ j) (loop @ k) @ i)
              [ (i = 0) -> <l> hcomp (join S1 S1)
                                     (pushP S1 S1 base1 base1 @ -l)
                                     [ (j = 0) -> <m> pushP S1 S1 base1 base1 @ (-m /\ -l)
                                     , (j = 1) -> <m> pushP S1 S1 base1 base1 @ (-m /\ -l)
                                     , (l = 0) -> <m> pushP S1 S1 (loop @ j) base1 @ -m
                                     , (l = 1) -> <m> inl base1 ]
              , (i = 1) -> <l> pushP S1 S1 base1 (loop @ k) @ -l
              , (j = 0) -> <l> pushP S1 S1 base1 (loop @ k) @ (i /\ -l)
              , (j = 1) -> <l> pushP S1 S1 base1 (loop @ k) @ (i /\ -l)
              , (k = 0) -> <l> hcomp (join S1 S1)
                                     (pushP S1 S1 base1 base1 @ -l)
                                     [ (i = 1) -> <m> pushP S1 S1 base1 base1 @ -l
                                     , (j = 0) -> <m> pushP S1 S1 base1 base1 @ ((i \/ -m) /\ -l)
                                     , (j = 1) -> <m> pushP S1 S1 base1 base1 @ ((i \/ -m) /\ -l)
                                     , (l = 0) -> <m> pushP S1 S1 (loop @ j) base1 @ (i \/ -m)
                                     , (l = 1) -> <m> inl base1 ]
              , (k = 1) -> <l> hcomp (join S1 S1)
                                     (pushP S1 S1 base1 base1 @ -l)
                                     [ (i = 1) -> <m> pushP S1 S1 base1 base1 @ -l
                                     , (j = 0) -> <m> pushP S1 S1 base1 base1 @ ((i \/ -m) /\ -l)
                                     , (j = 1) -> <m> pushP S1 S1 base1 base1 @ ((i \/ -m) /\ -l)
                                     , (l = 0) -> <m> pushP S1 S1 (loop @ j) base1 @ (i \/ -m)
                                     , (l = 1) -> <m> inl base1 ] ]


e : S3 -> join S1 S1 = split
  base3 -> inl base1
  loop3 @ i j k -> goalcube'' @ i @ j @ k

eInvAux2 : S1 -> Path (Path S3 base3 base3) (<_> base3) (<_> base3) = split
  base1 -> <_ _> base3
  loop1 @ i -> <j k> loop3{S3} @ i @ j @ k

eInvAux (x : S1) : S1 -> Path S3 base3 base3 = split
  base1 -> <_> base3
  loop1 @ i -> eInvAux2 x @ i

eInv : join S1 S1 -> S3 = split
  inl x -> base3
  inr y -> base3
  push x y @ i -> eInvAux x y @ i

merid : S1 -> Path S2 base2 base2 = split
  base1 -> <_> base2
  loop1 @ i -> <j> loop2{S2} @ i @ j

foo (x y : S1) : Path S2 base2 base2 =
  compPath S2 base2 base2 base2 (merid y) (merid x)

alpha : join S1 S1 -> S2 = split
  inl x -> base2
  inr y -> base2
  push x y @ i -> foo x y @ i


--
Sigma (A : U) (B : A -> U) : U = (x : A) * B x
refl (A : U) (a : A) : Path A a a = <i> a

constSquare (A : U) (a : A) (p : Path A a a) : Square A a a a a p p p p =
  <i j> hcomp A a [ (i = 0) -> <k> p @ (j \/ - k)
                  , (i = 1) -> <k> p @ (j /\ k)
                  , (j = 0) -> <k> p @ (i \/ - k)
                  , (j = 1) -> <k> p @ (i /\ k)]

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)
isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)
prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)
groupoid (A : U) : U = (a b : A) -> set (Path A a b)
twogroupoid (A : U) : U = (a b : A) -> groupoid (Path A a b)
threegroupoid (A : U) : U = (a b : A) -> twogroupoid (Path A a b)

SET : U = (A : U) * set A
GROUPOID : U = (A : U) * groupoid A

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path ((x : A) * Path A a x) (a,<_>a) (b,p) = <i> (p @ i,<j> p @ i/\j)

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<_>a),\(z : (x : A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

propSet (A : U) (h : prop A) : set A =
 \(a b : A) (p q : Path A a b) ->
   <j i> hcomp A a [ (i=0) -> h a a
                       , (i=1) -> h a b
                       , (j=0) -> h a (p @ i)
                       , (j=1) -> h a (q @ i)]

setGroupoid (A : U) (h : set A) : groupoid A =
  \(a b : A) -> propSet (Path A a b) (h a b)

groupoidTwoGroupoid (A : U) (h : groupoid A) : twogroupoid A =
  \(a b : A) -> setGroupoid (Path A a b) (h a b)

twogroupoidThreeGroupoid (A : U) (h : twogroupoid A) : threegroupoid A =
  \(a b : A) -> groupoidTwoGroupoid (Path A a b) (h a b)

propIsProp (A : U) : prop (prop A) =
  \(f g : prop A) -> <i> \(a b : A) ->
    propSet A f a b (f a b) (g a b) @ i

setIsProp (A : U) : prop (set A) =
 \(f g : set A) -> <i> \(a b :A) ->
   propIsProp (Path A a b) (f a b) (g a b) @ i

groupoidIsProp (A : U) : prop (groupoid A) =
 \(f g : groupoid A) -> <i> \(a b :A) ->
   setIsProp (Path A a b) (f a b) (g a b) @ i

propPi (A : U) (B : A -> U) (h : (x : A) -> prop (B x))
       (f0 f1 : (x : A) -> B x) : Path ((x : A) -> B x) f0 f1
  = <i> \ (x:A) -> (h x (f0 x) (f1 x)) @ i

-- propIsContr (A : U) (z0 z1 : isContr A) : Path (isContr A) z0 z1 =
--  <j> (p0 a1 @ j
--      ,\(x : A) -> <i> hcomp A (lem1 x@i@j)
--                               [ (i=0) -> <k> p0 a1 @ j
--                               , (i=1) -> <k> p0 x @ j \/ k
--                               , (j=0) -> <k> p0 x @ i/\ k
--                               , (j=1) -> <k> p1 x @ i ])
--  where
--   a0 : A = z0.1
--   p0 : (x : A) -> Path A a0 x = z0.2
--   a1 : A = z1.1
--   p1 : (x : A) -> Path A a1 x = z1.2
--   lem1 (x : A) : PathP (<i> Path A a0 (p1 x @ i)) (p0 a1) (p0 x) =
--     <i j> p0 (p1 x @ i) @ j

-- propIsEquiv (A B : U) (f : A -> B) : prop (isEquiv A B f) =
--   \(u0 u1 : isEquiv A B f) -> <i> \(y : B) -> propIsContr (fiber A B f y) (u0 y) (u1 y) @ i

-- -- Direct proof, not much better than propIsEquiv...
-- propIsEquivDirect (A B : U) (f : A -> B) : prop (isEquiv A B f) =
--   \(p q : isEquiv A B f) ->
--   <i> \(y : B) ->
--     let p0 : A = (p y).1.1
--         p1 : Path B y (f p0) = (p y).1.2
--         p2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (p0,p1) w1 =
--          (p y).2
--         q0 : A = (q y).1.1
--         q1 : Path B y (f q0) = (q y).1.2
--         q2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (q0,q1) w1 =
--          (q y).2
--     in (p2 (q y).1 @ i,
--        \(w : fiber A B f y) ->
--           let sq : PathP (<j> Path (fiber A B f y) (p2 (q0,q1) @ j) w) (p2 w) (q2 w) = 
--                      <i j> hcomp (fiber A B f y) (p2 w @ i \/ j)
--                                  [ (i = 0) -> <k> p2 w @ j
--                                  , (i = 1) -> <k> q2 w @ j \/ -k
--                                  , (j = 0) -> <k> p2 (q2 w @ -k) @ i
--                                  , (j = 1) -> <k> w ]
--           in sq @ i)

-- The grad lemma

lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = <i> (p @ i,sq1 @ i)
  where
    rem0 : Path A (g y) x0 =
      <i> hcomp A (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem1 : Path A (g y) x1 =
      <i> hcomp A (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    p : Path A x0 x1 =
     <i> hcomp A (g y) [ (i = 0) -> rem0
                            , (i = 1) -> rem1 ]

    fill0 : Square A (g y) (g (f x0)) (g y) x0
                     (<i> g (p0 @ i)) rem0 (<i> g y) (t x0)  =
      <i j> hcomp A (g (p0 @ i)) [ (i = 1) -> <k> t x0 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p0 @ i) ]

    fill1 : Square A (g y) (g (f x1)) (g y) x1
                     (<i> g (p1 @ i)) rem1 (<i> g y) (t x1) =
      <i j> hcomp A (g (p1 @ i)) [ (i = 1) -> <k> t x1 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p1 @ i) ]

    fill2 : Square A (g y) (g y) x0 x1
                     (<k> g y) p rem0 rem1 =
      <i j> hcomp A (g y) [ (i = 0) -> <k> rem0 @ j /\ k
                               , (i = 1) -> <k> rem1 @ j /\ k
                               , (j = 0) -> <k> g y ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
                  (<i> g y) (<i> g (f (p @ i)))
                  (<j> g (p0 @ j)) (<j> g (p1 @ j)) =
      <i j> hcomp A (fill2 @ i @ j) [ (i = 0) -> <k> fill0 @ j @ -k
                                         , (i = 1) -> <k> fill1 @ j @ -k
                                         , (j = 0) -> <k> g y
                                         , (j = 1) -> <k> t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
                   (<k>y) (<i> f (p @ i)) p0 p1 =
      <i j> hcomp B (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j)
                                         , (i = 1) -> s (p1 @ j)
                                         , (j = 1) -> s (f (p @ i))
                                         , (j = 0) -> s y ]

gradLemma (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
  \(y:B) -> ((g y,<i>s y@-i),\ (z:fiber A B f y) ->
    lemIso A B f g s t y (g y) z.1 (<i>s y@-i) z.2)

-- Unfolded direct proof. This has a simpler normal form without transGen's!
propIsEquivDirect' (A B : U) (f : A -> B) : prop (isEquiv A B f) =
  \(p q : isEquiv A B f) ->
  <i> \(y : B) ->
    let p0 : A = (p y).1.1
        p1 : Path B y (f p0) = (p y).1.2
        p2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (p0,p1) w1 =
         (p y).2
        q0 : A = (q y).1.1
        q1 : Path B y (f q0) = (q y).1.2
        q2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (q0,q1) w1 =
         (q y).2
        alpha : Path (fiber A B f y) (p0,p1) (q0,q1) = p2 (q y).1
    in (alpha @ i,
       \(w : fiber A B f y) ->
          let x : A = w.1
              wx : Path B y (f x) = w.2
              alpha1 : Path A p0 q0 = <i> (alpha @ i).1
              alpha2 : PathP (<i> Path B y (f (alpha1 @ i))) p1 q1 =
                <i> (alpha @ i).2
              p2w1 : Path A p0 x = <i> (p2 w @ i).1
              q2w1 : Path A q0 x = <i> (q2 w @ i).1
              p2w2 : PathP (<i> Path B y (f (p2w1 @ i))) p1 wx = <i> (p2 w @ i).2
              q2w2 : PathP (<i> Path B y (f (q2w1 @ i))) q1 wx = <i> (q2 w @ i).2
              sq1 : PathP (<j> Path A (alpha1 @ j) x) p2w1 q2w1 =
                    <i j> hcomp A (p2w1 @ i \/ j)
                                 [ (i = 0) -> <k> p2w1 @ j
                                 , (i = 1) -> <k> q2w1 @ j \/ -k
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                 , (j = 1) -> <k> x ]
              sq2 : PathP (<i> PathP (<j> Path B y (f (sq1 @ i @ j)))
                                     (alpha2 @ i) wx)
                          p2w2 q2w2 =
                     <i j l> hcomp B (p2w2 @ i \/ j @ l)
                                 [ (i = 0) -> <k> p2w2 @ j @ l
                                 , (i = 1) -> <k> q2w2 @ j \/ -k @ l
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).2 @ l
                                 , (j = 1) -> <k> wx @ l
                                 , (l = 0) -> <k> y
                                 , (l = 1) -> <k> f (hfill A (p2w1 @ i \/ j)
                                                        [ (i = 0) -> <k> p2w1 @ j
                                                        , (i = 1) -> <k> q2w1 @ j \/ -k
                                                        , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                                        , (j = 1) -> <k> x ] @ k)
                                 ]
          in <j> (sq1 @ i @ j,sq2 @ i @ j))

ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

rotLoop : (a : S1) -> Path S1 a a = split
  base1 -> loop
  loop1 @ i -> constSquare S1 base1 loop @ i

rot : S1 -> S1 -> S1 = split
  base1 -> \(y : S1) -> y
  loop1 @ i -> \(y : S1) -> rotLoop y @ i

-- Specialized version for S1:
lemPropFS1 (P : S1 -> U) (pP : (x : S1) -> prop (P x)) 
         (b0 : P base1) : PathP (<i> P (loop @ i)) b0 b0 =
  <i> pP (loop @ i) (transGen (<j> P (loop @ i /\ j)) (-i) b0)
                    (transGen (<j> P (loop @ i \/ -j)) i b0) @ i

rotIsEquiv_loop : PathP (<i> isEquiv S1 S1 (rot (loop @ i))) (idIsEquiv S1) (idIsEquiv S1) =
  lemPropFS1 (\(a : S1) -> isEquiv S1 S1 (rot a))
             (\(a : S1) -> propIsEquivDirect' S1 S1 (rot a)) 
             (idIsEquiv S1) 

-- isPropOver (A0 A1 : U) (A : Path U A0 A1) (p : prop A1) : U =
--   (a0 : A0) (a1 : A1) -> PathP A a0 a1

propToPropOver (A : U) (L : Path U A A) (p : (a0 a1 : A) -> Path A a0 a1) (a0 : A) : PathP L a0 a0 =
  <i> hcomp (L @ i) (transGen (<j> L @ i /\ j) (-i) a0)
              [ (i=0) -> <_> a0
              , (i=1) -> p (transGen L 0 a0) a0 ]

-- Alternative version inspired by redtt
rotIsEquiv_loop_alt : PathP (<i> isEquiv S1 S1 (rot (loop @ i))) (idIsEquiv S1) (idIsEquiv S1) =
  propToPropOver
       (isEquiv S1 S1 (\(a : S1) -> a))
       (<i> isEquiv S1 S1 (rot (loop @ i)))
       (propIsEquivDirect' S1 S1 (\(a : S1) -> a))
       (idIsEquiv S1)

-- Can this be simplified? The second argument is essentially propIsEquivDirect
isContrIdIsEquiv (A : U) : isContr (isEquiv A A (idfun A)) = (idIsEquiv A,goal)
  where
  goal (q : isEquiv A A (idfun A)) : Path (isEquiv A A (idfun A)) (idIsEquiv A) q =
    <i> \(y : A) -> (((q y).1.2 @ i,<j> (q y).1.2 @ i /\ j)
       ,\(w : (x : A) * Path A y x) ->
         <j> (hcomp A (w.2 @ i \/ j)
                      [(i=0) -> <_> w.2 @ j
                      ,(i=1) -> <k> ((q y).2 w @ j \/ -k).1
                      ,(j=0) -> <k> ((q y).2 w @ -k).2 @ i
                      ,(j=1) -> <_> w.1]
             ,<k> hcomp A (w.2 @ (i \/ j) /\ k)
                          [(i=0) -> <_> w.2 @ j /\ k
                          ,(i=1) -> <l> ((q y).2 w @ j \/ -l).2 @ k
                          ,(j=0) -> <l> ((q y).2 w @ -l).2 @ i /\ k
                          ,(j=1) -> <_> w.2 @ k
                          ,(k=0) -> <_> y
                          ,(k=1) -> <l> hfill A (w.2 @ i \/ j)
                                                [(i=0) -> <_> w.2 @ j
                                                ,(i=1) -> <k> ((q y).2 w @ j \/ -k).1
                                                ,(j=0) -> <k> ((q y).2 w @ -k).2 @ i
                                                ,(j=1) -> <_> w.1] @ l]))

    -- <i> \(y : A) -> -- propIsContr (fiber A A (idfun A) y) (idIsEquiv A y) (q y) @ i
    -- let q0 : A = (q y).1.1
    --     q1 : Path A y q0 = (q y).1.2
    --     q2 : (w1 : (x : A) * Path A y x) -> Path ((x : A) * Path A y x) (q0,q1) w1 = (q y).2
    -- in ((q1 @ i,<j> q1 @ i /\ j),
    --    \(w : (x : A) * Path A y x) ->
    --       let sq : PathP (<j> Path ((x : A) * Path A y x) (q1 @ j,<k> q1 @ j /\ k) w)
    --                      (<i> (w.2 @ i,<j> w.2 @ i /\ j)) (q2 w) =
    --                  <i j> hcomp ((x : A) * Path A y x) ((w.2 @ i \/ j,<k> w.2 @ (i \/ j) /\ k))
    --                              [ (i = 0) -> <_> (w.2 @ j,<k> w.2 @ j /\ k)
    --                              , (i = 1) -> <k> q2 w @ j \/ -k
    --                              , (j = 0) -> <k> ((q2 w @ -k).2 @ i,<j> (q2 w @ -k).2 @ i /\ j)
    --                              , (j = 1) -> <_> w ]
    --       in sq @ i)

-- Unfolded version inspired by redtt
rotIsEquiv_loop_alt_unf : PathP (<i> isEquiv S1 S1 (rot (loop @ i))) (idIsEquiv S1) (idIsEquiv S1) =
  <i> \(y : S1) -> hcomp (isEquiv S1 S1 (rot (loop @ i)))
            (transGen (<j> isEquiv S1 S1 (rot (loop @ i /\ j))) (-i) (idIsEquiv S1))
              [ (i=0) -> <_> idIsEquiv S1
              , (i=1) -> <i> (isContrIdIsEquiv S1).2 (transGen (<i> isEquiv S1 S1 (rot (loop @ i))) 0 (idIsEquiv S1)) @ -i] y

rotIsEquiv : (a : S1) -> isEquiv S1 S1 (rot a) = split
   base1 -> idIsEquiv S1
   loop1 @ i -> rotIsEquiv_loop_alt_unf @ i

-- Alternative version of rotIsEquiv
subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

-- Specialized version of pathSIntro for S1
pathSIntroS1 (C : S1 -> U) (c : C base1)
           (w : Path (C base1) (transGen (<i> C (loop @ i)) 0 c) c) :
  PathP (<i> C (loop @ i)) c c =
  transGen (<j> PathP (<i> C (loop @ -j \/ i))
                      (transGen (<i> C (loop @ -j /\ i)) j c) c) 0 w

s1elim (C : S1 -> U) (c : C base1) (p : Path (C base1) (subst S1 C base1 base1 loop c) c) :
  (x : S1) -> C x = split
  base1 -> c
  loop1 @ i -> pathSIntroS1 C c p @ i

-- We can also use this, but it doesn't seem faster than the version with s1elim
-- lemPropFS1' (P : S1 -> U) (pP : (x : S1) -> prop (P x)) 
--            (b0 : P base1) : PathP (<i> P (loop @ i)) b0 b0 =
--   pathSIntroS1 P b0 (pP base1 (transGen (<i795625> P (loop1 {S1} @ i795625)) 0 b0) b0)

rotIsEquiv' : (a : S1) -> isEquiv S1 S1 (rot a) =
  s1elim (\(x : S1) -> isEquiv S1 S1 (rot x))
         (idIsEquiv S1) p
   where
   p : Path (isEquiv S1 S1 (rot base1))
            (subst S1 (\(x : S1) -> isEquiv S1 S1 (rot x)) base1 base1 loop (idIsEquiv S1)) (idIsEquiv S1) =
              propIsEquivDirect' S1 S1 (rot base1) (subst S1 (\(x : S1) -> isEquiv S1 S1 (rot x))
                                 base1 base1 loop (idIsEquiv S1)) (idIsEquiv S1)

inv : S1 -> S1 = split
  base1 -> base1
  loop1 @ i -> loop @ -i

rotrotinvloop1loop1 :
 PathP (<i>
  PathP (<j>
   Path S1 (hcomp S1 (loop @ j)
                  [(i=0) -> <k> hcomp S1 base1
                                      [(k=0) -> <l> loop @ (j /\ l)
                                      ,(j=0) -> <_> base1
                                      ,(j=1) -> <l> loop @ (-k /\ l)]
                  ,(i=1) -> <k> hcomp S1 base1
                                      [(k=0) -> <l> loop @ (j \/ -l)
                                      ,(j=0) -> <l> loop @ (k \/ -l)
                                      ,(j=1) -> <_> base1]
                  ,(j=1) -> <k> loop @ (i \/ -k)
                  ,(j=0) -> <k> loop @ (i /\ k)])
           (loop @ i))
    (<_> loop @ i)
    (<_> loop @ i))
  (<j k> hfill S1 base1 [(j=0) -> <_> base1, (j=1) -> <_> base1] @ -k)
  (<j k> hfill S1 base1 [(j=0) -> <_> base1, (j=1) -> <_> base1] @ -k) = undefined

 -- <i j k>
 --   hcomp S1 (hcomp S1 (loop @ (k \/ j))
 --                  [(i=0) -> <m> hcomp S1 (loop @ k)
 --                                      [(m=0) -> <l> loop @ (k \/ (j /\ l))
 --                                      ,(j=0) -> <_> loop @ k
 --                                      ,(j=1) -> <l> loop @ (k \/ (-m /\ l))]
 --                  ,(i=1) -> <m> hcomp S1 base1
 --                                      [(m=0) -> <l> loop @ (k \/ (j \/ -l))
 --                                      ,(j=0) -> <l> loop @ (k \/ (m \/ -l))
 --                                      ,(j=1) -> <_> base1]
 --                  ,(j=1) -> <m> loop @ (k \/ (i \/ -m))
 --                  ,(j=0) -> <m> loop @ (k \/ (i /\ m))])
 --         [(k=0) -> <_> (hcomp S1 (loop @ j)
 --                  [(i=0) -> <k> hcomp S1 base1
 --                                      [(k=0) -> <l> loop @ (j /\ l)
 --                                      ,(j=0) -> <_> base1
 --                                      ,(j=1) -> <l> loop @ (-k /\ l)]
 --                  ,(i=1) -> <k> hcomp S1 base1
 --                                      [(k=0) -> <l> loop @ (j \/ -l)
 --                                      ,(j=0) -> <l> loop @ (k \/ -l)
 --                                      ,(j=1) -> <_> base1]
 --                  ,(j=1) -> <k> loop @ (i \/ -k)
 --                  ,(j=0) -> <k> loop @ (i /\ k)])
 --         ,(k=1) -> <m> hfill S1 (loop @ (-m \/ i)) [(i=0) -> <l> hcomp S1 (loop @ -m) [(l=0) -> <_> (loop @ -m), (j=0) -> <_> (loop @ -m), (j=1) -> <_> (loop @ -m)], (i=1) -> <l> hcomp S1 base1 [(l=0) -> <_> base1, (j=0) -> <_> base1, (j=1) -> <_> base1], (j=1) -> <l> loop @ (-m \/ i), (j=0) -> <l> loop @ (-m \/ i)] @ -m
 --         ,(j=0) -> <m> loop @ (i \/ (k /\ -m))
 --         ,(j=1) -> <m> loop @ (i \/ (k /\ -m))
 --         ]

rotrotinvloop1 : (y : S1) -> PathP (<i> Path S1 (rotLoop (rotLoop y @ -i) @ i) y) (<_> y) (<_> y) = split
  base1 -> <i j> hfill S1 base1 [(i=0) -> <_> base1, (i=1) -> <_> base1] @ -j
  loop1 @ i -> rotrotinvloop1loop1 @ i



-- -- rotinvrotloop1 : (y : S1) -> PathP (<i> Path S1 (rotLoop (rotLoop y @ i) @ -i) y) (<_> y) (<_> y) = undefined

-- rotrotinv : (a y : S1) -> Path S1 (rot a (rot (inv a) y)) y = split
--   base1 -> \ (y : S1) -> <_> y
--   loop1 @ i -> \ (y : S1) -> (rotrotinvloop1 y) @ i

-- rotinvrot : (a y : S1) -> Path S1 (rot (inv a) (rot a y)) y = split
--   base1 -> \ (y : S1) -> <_> y
--   loop1 @ i -> \ (y : S1) -> (rotrotinvloop1 y) @ -i

-- opaque rotrotinvloop1
-- opaque rotinvrotloop1

-- rotIsEquiv'' (a : S1) : isEquiv S1 S1 (rot a) =
--   gradLemma S1 S1 (rot a) (rot (inv a)) (rotrotinv a) (rotinvrot a)
  
  

goal (A : U) : Path (Path U A A) (ua A A (idEquiv A)) (<_> A) =
  <j i> Glue A [ (i = 0) -> (A,idEquiv A)
               , (i = 1) -> (A,idEquiv A)
               , (j = 1) -> (A,idEquiv A) ]

-- We're hiding univalence in there
-- square : Path (Path U S1 S1) (<_> S1) (<_> S1) =
--   <i j> Glue S1 [ (i = 0) -> (S1, (rot base1 , rotIsEquiv'' base1))
--                 , (i = 1) -> (S1, (rot base1 , rotIsEquiv'' base1))
--                 , (j = 0) -> (S1, (rot (loop @ i), rotIsEquiv'' (loop @ i)))
--                 , (j = 1) -> (S1, (rot base1 , rotIsEquiv'' base1))
--                 ]

square : Path (Path U S1 S1) (<_> S1) (<_> S1) =
  <i j> Glue S1 [ (i = 0) -> (S1, idEquiv S1)
                , (i = 1) -> (S1, idEquiv S1)
                , (j = 0) -> (S1, (rot (loop @ i), rotIsEquiv (loop @ i)))
                , (j = 1) -> (S1, idEquiv S1)
                ]

Hopf : S2 -> U = split
  base2 -> S1
  loop2 @ i j -> square @ i @ j


-- We want to construct a map from the total space of the Hopf fibration to [join S1 S1]
-- We do that by composing four maps
-- total space of Hopf -> PreTotalHopf -> PostTotalHopf -> AlmostJoinS1S1 -> join S1 S1

data PreTotalHopf =
    b (x : S1)
  | l (x : S1) <i j> [ (i=0) -> b x
                     , (i=1) -> b (transGen (<l> square @ l @ (l /\ j)) 0 x)
                     , (j=0) -> b x
                     , (j=1) -> b (transGen (<l> square @ (l /\ i) @ l) 0 x) ]

data PostTotalHopf =
    b (x : S1)
  | l (x : S1) <i j> [ (i=0) -> b x
                     , (i=1) -> b x
                     , (j=0) -> b x
                     , (j=1) -> b (rot (loop @ i) x) ]

data PostTotalHopf2 =
    b (x : S1)
  | l (x : S1) <i j> [ (i=0) -> b x
                     , (i=1) -> b x
                     , (j=0) -> b (rot (loop @ -i) x)
                     , (j=1) -> b x ]

data AlmostJoinS1S1 =
    inl (x : S1)
  | inr (x : S1)
  | push (x y : S1) <i> [ (i=0) -> inl x , (i=1) -> inr (rot y x) ]

test : (x : S2) -> Hopf x -> PostTotalHopf2 = split
  base2 -> \ (y : S1) -> b y
  loop2 @ i j -> \ (y : square @ i @ j) ->
        hcomp PostTotalHopf2 (l{PostTotalHopf2} (unglue y S1 [ (i = 0) -> (S1, idEquiv S1)
                                                             , (i = 1) -> (S1, idEquiv S1)
                                                             , (j = 0) -> (S1, (rot (loop @ i), rotIsEquiv (loop @ i)))
                                                             , (j = 1) -> (S1, idEquiv S1)]) @ i @ j)
              [(i=0) -> <_> b y
              ,(i=1) -> <_> b y
              ,(j=0) -> <k> b (rotrotinvloop1 y @ -i @ k)
              ,(j=1) -> <_> b y]

-- [(i=0) -> (\ (y : S1) -> b y)
-- ,(i=1) -> (\ (y : S1) -> b y)
-- ,(j=0) -> (\ (y : S1) -> b (rot (loop @ i) y))
-- ,(j=1) -> (\ (y : S1) -> b (rot (loop @ i) y))]

tee1 : (x : S2) -> Hopf x -> PreTotalHopf = split
  base2 -> (\ (y : S1) -> b y)
  loop2 @ i j -> (\ (y : Hopf (loop2{S2} @ i @ j)) ->
        hcomp PreTotalHopf
             (l{PreTotalHopf} (transGen (<l> square @ (-l /\ i) @ (-l /\ j)) 0 y) @ i @ j)
             [ (i=0) -> <k> b y
             , (i=1) -> <k> b (transGen (<l> square @ (i /\ (l \/ k)) @ (j /\ (l \/ k))) 0
                                (transGen (<l> square @ (i /\ (-l \/ k)) @ (j /\ (-l \/ k))) 0 y))
             , (j=0) -> <k> b y
             , (j=1) -> <k> b (transGen (<l> square @ (i /\ (l \/ k)) @ (j /\ (l \/ k))) 0
                                (transGen (<l> square @ (i /\ (-l \/ k)) @ (j /\ (-l \/ k))) 0 y))
             ])

a (x : S1) : S1 = hcomp S1 (hcomp S1 x []) []
aeq (x : S1) : Path S1 (a x) x = <k> transGen (<l> square @ (k \/ l) @ l) 0 x

side1 (x : S1) : Square S1 x (a x) x x (<j> transGen (<l> square @ l @ (l /\ j)) 0 x)
                                       (<_> x)
                                       (<_> x)
                                       (aeq x) =
  <j> <k> transGen (<l> square @ (l \/ k) @ (l /\ j)) 0 x

side2 (x : S1) : Square S1 x (a x) x x (<i> transGen (<l> square @ (l /\ i) @ l) 0 x)
                                       (<i> rot (loop @ i) x)
                                       (<_> x)
                                       (aeq x) =
  <i> <j> hfill S1 (hfill S1 (rotLoop x @ (i /\ j)) [ (i = 0) -> <_> x ] @ -j) [ (i = 0) -> <_> x ] @ -j

tee2 : PreTotalHopf -> PostTotalHopf = split
  b x -> b x
  l x @ i j -> hcomp PostTotalHopf (l{PostTotalHopf} x @ i @ j)
                     [ (i=0) -> <_> b x
                     , (i=1) -> <k> b (side1 x @ j @ -k)
                     , (j=0) -> <_> b x
                     , (j=1) -> <k> b (side2 x @ i @ -k)]

tee3 : PostTotalHopf -> AlmostJoinS1S1 = split
  b x -> inr x
  l x @ i j -> hcomp AlmostJoinS1S1 (push{AlmostJoinS1S1} x (loop @ i) @ j)
                     [ (i=0) -> <k> push {AlmostJoinS1S1} x base1 @ (j \/ k)
                     , (i=1) -> <k> push {AlmostJoinS1S1} x base1 @ (j \/ k)
                     , (j=0) -> <k> push {AlmostJoinS1S1} x base1 @ k
                     , (j=1) -> <_> inr (rot (loop @ i) x)]

tee4 : AlmostJoinS1S1 -> join S1 S1 = split
  inl x -> inr x
  inr y -> inl y
  push x y @ i -> push{join S1 S1} (rot y x) x @ -i

tee : (x : S2) -> (Hopf x -> join S1 S1) = \(x : S2) (y : Hopf x) -> tee4 (tee3 (tee2 (tee1 x y)))

-- Experiment with suspension

data susp (A : U) = north
                  | south
                  | merid (a : A) <i> [ (i=0) -> north
                                      , (i=1) -> south ]

meridP (A : U) (a : A) : Path (susp A) north south =
  <i> merid{susp A} a @ i

s2tosusps1 : S2 -> susp S1 = split
  base2 -> north
  loop2 @ i j ->
    hcomp (susp S1) (meridP S1 (loop @ j) @ i)
                    [ (i=0) -> <_> north
                    , (i=1) -> <k> meridP S1 base1 @ -k
                    , (j=0) -> <k> meridP S1 base1 @ -k /\ i
                    , (j=1) -> <k> meridP S1 base1 @ -k /\ i ]


rotpath (x : S1) : Path U S1 S1 =
  <i> Glue S1 [ (i = 0) -> (S1,(rot x, rotIsEquiv x))
              , (i = 1) -> (S1,idEquiv S1) ]

Hopfsusp : susp S1 -> U = split
  north -> S1
  south -> S1
  merid x @ i -> rotpath x @ i

rotInvBase : (b : S1) -> Path S1 (rot (rot b base1) (inv b)) base1 = split
  base1 -> <_> base1
  loop1 @ k -> <i> hcomp S1 (rot (loop @ k \/ i) (loop @ - k))
                            [ (k=0) -> <l> loop @ i /\ -l
                            , (k=1) -> <_> base1
                            , (i=0) -> <_> rot (loop @ k) (loop @ -k)
                            , (i=1) -> <l> loop @ -k /\ -l ]

rotInvLoop : (b : S1) -> PathP (<i> Path S1 (rot (rot b (loop @ i)) (inv b)) (loop @ i))
                               (rotInvBase b) (rotInvBase b) = split
  base1 -> <j _> loop @ j
  loop1 @ k -> <j i> hcomp S1
                           (rot (rot (loop @ k \/ i) (loop @ j)) (loop @ - k))
                           [ (k=0) -> <l> rot (loop @ i /\ - l) (loop @ j)
                           , (k=1) -> <_> loop @ j
                           , (i=0) -> <_> rot (rot (loop @ k) (loop @ j)) (loop @ - k)
                           , (i=1) -> <l> rot (loop @ - k /\ - l) (loop @ j) ]

rotInv : (a b : S1) -> Path S1 (rot (rot b a) (inv b)) a = split
  base1 -> rotInvBase
  loop1 @ j -> \(b : S1) -> rotInvLoop b @ j

TotalHopftoJoinS1S1 : (x : susp S1) -> Hopfsusp x -> join S1 S1 = split
  north -> \(x : S1) -> inl x
  south -> \(x : S1) -> inr x
  merid y @ j -> \(x : rotpath y @ j) ->
    hcomp (join S1 S1)
          (push{join S1 S1}
                (rot (unglue x S1 [ (j = 0) -> (S1,(rot y, rotIsEquiv y))
                                  , (j = 1) -> (S1,idEquiv S1) ]) (inv y))
                (unglue x S1 [ (j = 0) -> (S1,(rot y, rotIsEquiv y))
                             , (j = 1) -> (S1,idEquiv S1) ]) @ j)
          [ (j = 0) -> <t> inl (rotInv x y @ t)
          , (j = 1) -> <_> inr x ]

-- Hopf (x : S2) : U = Hopfsusp (s2tosusps1 x)

-- TotalHopf2toJoinS1S1 (x : S2) : Hopf x -> join S1 S1 =
--   TotalHopftoJoinS1S1 (s2tosusps1 x)


-- Alternative Hopf, doesn't seem to compute differently
-- lemSig (A : U) (B : A -> U) (pB : (x : A) -> prop (B x))
--        (u v : (x:A) * B x) (p : Path A u.1 v.1) :
--        Path ((x:A) * B x) u v = <i> (p @ i, lemPropF A B pB u.1 v.1 p u.2 v.2 @ i)

-- equivEq (A B : U) (v w : equiv A B) (p : Path (A -> B) v.1 w.1) : Path (equiv A B) v w =
--   lemSig (A -> B) (isEquiv A B) (propIsEquivDirect' A B) v w p

-- mu : S1 -> equiv S1 S1 = split
--   base1 -> idEquiv S1
--   loop1 @ i ->
--     let f : (x : S1) -> Path S1 x x = split
--           base1 -> loop
--           loop1 @ i -> constSquare S1 base1 loop @ i
--         goal : Path (equiv S1 S1) (idEquiv S1) (idEquiv S1) =
--           equivEq S1 S1 (idEquiv S1) (idEquiv S1) (<j> \(x : S1) -> f x @ j)
--     in goal @ i

-- Hopf' : S2 -> U = split
--   base2 -> S1
--   loop2 @ i j -> hcomp U (ua S1 S1 (mu (loop @ i)) @ j)
--                        [ (i=0) -> <k> goal S1 @ k @ j
--                        , (i=1) -> <k> goal S1 @ k @ j
--                        , (j=0) -> <_> S1
--                        , (j=1) -> <_> S1 ]

-----
subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

substInv (A : U) (P : A -> U) (a b : A) (p : Path A a b) : P b -> P a =
  subst A P b a (<i> p @ -i)

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
    subst ((x : A) * Path A a x) T (a,<_> a) (x, p) (contrSingl A a x p) d
      where T (z : (x : A) * Path A a x) : U = C (z.1) (z.2)

PathS (A : U) (P : A -> U) (a0 a1 : A) (p : Path A a0 a1) (u0 : P a0) (u1 : P a1) : U =
  PathP (<i> P (p @ i)) u0 u1

transGen0 (A : U) (a : A) : A = transGen (<_> A) 0 a

-- this could use comp3
lemTransGen0 (A : U) (a : A) : Path A (transGen0 A a) a =
-- let rem1 : Path A a (hcomp A (transGen (<_> A) 0 a) []) = fill (<_> A) a []
--     rem2 : Path A (transGen (<_> A) 0 a) (hcomp A (transGen (<_> A) 0 a) []) =
--       hfill A (transGen (<_> A) 0 a) []
-- in compPath A (transGen0 A a) (hcomp A (transGen (<_> A) 0 a) []) a rem2 (<i> rem1 @ -i)
  <i> transGen (<_> A) i a

-- This is a bit weird
-- lemTransGen0' (A : U) (a : A) : Path A (transGen0 A a) (hcomp A a []) =
--   let rem : Path A a (hcomp A a []) = hfill A a []
--   in compPath A (transGen0 A a) a (hcomp A a []) (lemTransGen0 A a) rem

-- Define these directly and unfolded makes the definition of itTotalFibOmega3 extremely simple
fibOmega (B : ptType) (P : B.1 -> U) (f : P (pt B)) (p : (Omega B).1) : U =
  PathS B.1 P (pt B) (pt B) p f f
itFibOmega2 (B : ptType) (P : B.1 -> U) (f : P (pt B)) : (Omega2 B).1 -> U =
  fibOmega (Omega B) (fibOmega B P f) (<_> f)
itFibOmega3 (B : ptType) (P : B.1 -> U) (f : P (pt B)) : (Omega3 B).1 -> U =
  itFibOmega2 (Omega B) (fibOmega B P f) (<_> f)

-- itTotalFibOmega3 (B : ptType) (P : B.1 -> U) (f : P (pt B))
--   (x : Sigma (Omega3 B).1 (itFibOmega3 B P f)) : (Omega3 (Sigma B.1 P, (pt B, f))).1 =
--   <i j k> (x.1 @ i @ j @ k,x.2 @ i @ j @ k)

-- B.8.3 Looping the Hopf fibration

HopfOne : (Omega S2pt).1 -> U = fibOmega S2pt Hopf base1

HopfTwo : (Omega2 S2pt).1 -> U = itFibOmega2 S2pt Hopf base1

HopfThree : (Omega3 S2pt).1 -> U = itFibOmega3 S2pt Hopf base1

inhOrTrunc (A : U) : nat -> U = split
  zero  -> A
  suc n -> (x y : A) -> inhOrTrunc (Path A x y) n

funDepTr (A : U) (P : A -> U) (a0 a1 : A) (p : Path A a0 a1) (u0 : P a0) (u1 : P a1) :
         Path U (PathP (<i> P (p @ i)) u0 u1)
                (Path (P a1) (subst A P a0 a1 p u0) u1) =
  <j> PathP (<i> P (p @ j \/ i)) (transGen (<i> P (p @ j /\ i)) (-j) u0) u1

truncFibOmega (n : nat) (B : ptType) (P : B.1 -> U) (f : P (pt B))
  (tr : inhOrTrunc (P (pt B)) (suc n)) (p : (Omega B).1) : inhOrTrunc (fibOmega B P f p) n =
  let trf : inhOrTrunc (Path (P B.2) (subst B.1 P (pt B) (pt B) p f) f) n =
        tr (subst B.1 P (pt B) (pt B) p f) f
      eq : Path U (Path (P (pt B)) (subst B.1 P (pt B) (pt B) p f) f)
                  (PathP (<i> P (p @ i)) f f) =
                    <i> funDepTr B.1 P (pt B) (pt B) p f f @ -i
  in transGen (<i> inhOrTrunc (eq @ i) n) 0 trf

-- alternative attempt:

-- This first version seems inefficient as things are not pointed by
-- refl. Below is a version instantiated with S2pt which seems better.

-- fibOmega' (B : ptType) (P : B.1 -> U) (f : P (pt B)) (p : (Omega B).1) : U =
--   Path (P (pt B)) (subst B.1 P (pt B) (pt B) p f) f

-- ptFibOmega' (B : ptType) (P : B.1 -> U) (f : P (pt B)) : fibOmega' B P f (<_> B.2) =
--   lemTransGen0 (P (pt B)) f

-- itFibOmega2' (B : ptType) (P : B.1 -> U) (f : P (pt B)) : (Omega2 B).1 -> U =
--   fibOmega' (Omega B) (fibOmega' B P f) (ptFibOmega' B P f)

-- ptItFibOmega2' (B : ptType) (P : B.1 -> U) (f : P (pt B)) : itFibOmega2' B P f (<_ _> B.2) =
--   ptFibOmega' (Omega B) (fibOmega' B P f) (ptFibOmega' B P f)

-- itFibOmega3' (B : ptType) (P : B.1 -> U) (f : P (pt B)) : (Omega3 B).1 -> U =
--   fibOmega' (Omega2 B) (itFibOmega2' B P f) (ptItFibOmega2' B P f)

-- HopfOne' : (Omega S2pt).1 -> U = fibOmega' S2pt Hopf base1
-- HopfThree' : (Omega3 S2pt).1 -> U = itFibOmega3' S2pt Hopf base1

-- We only need these when B is S2pt, P is Hopf and f is
-- base1. In this case they have simpler definitions because of the
-- computation rule "transGen (<_> S1) 0 a = a" (which has been
-- hard-coded):

-- The simple general versions of "looping a fibration":
fibOmega' (B : ptType) (P : B.1 -> U) (f : P (pt B)) (p : (Omega B).1) : U =
  Path (P (pt B)) (subst B.1 P (pt B) (pt B) p f) f

-- itFibOmega1' (p : (Omega S2pt).1) : U = fibOmega' S2pt Hopf base1 p

-- itFibOmega2' (p : (Omega2 S2pt).1) : U =
  -- fibOmega' (Omega S2pt) itFibOmega1' (<_> base1) p
--   Path loopS1 (<j> transGen (<k> Hopf (p @ j @ k)) 0 base1) (<_> base1)

-- itFibOmega3eq : Path loopS1 (<i> hcomp S1 base1 [(i=0) -> <_> base1,(i=1) -> <_> base1]) (<i> base1) =
--   <i> hfill loopS1 (<_> base1) [] @ -i


-- I hardcode this to be the simplest thing possible. Is this ok? If
-- not uncomment commented code...
itFibOmega3' (p : (Omega3 S2pt).1) : U =
  Path (Path loopS1 (<_> base1) (<_> base1))
       (<j k> transGen (<l> Hopf (p @ j @ k @ l)) 0 base1)
       (<_ _> base1)
  -- fibOmega' (Omega2 S2pt) itFibOmega2' itFibOmega3eq p


-- B.8.3 Looping the Hopf fibration

-- The normal form of these are not too bad

-- -- HopfOne' : (Omega S2pt).1 -> U = fibOmega' S2pt Hopf base1
-- -- HopfTwo' : (Omega2 S2pt).1 -> U = itFibOmega2'
-- HopfThree' : (Omega3 S2pt).1 -> U = itFibOmega3'

HopfOne'    (p : (Omega S2pt).1)  : U = Path S1      (transGen (<i> Hopf     (p @ i)) 0       base1) base1
HopfTwo'    (p : (Omega2 S2pt).1) : U = Path loopS1  (transGen (<j> HopfOne' (p @ j)) 0 (<_> base1)) (<_> base1)
HopfTwo'pt : HopfTwo' (<_ _> base2) = <i> hfill loopS1 (<_> base1) [] @ -i
HopfThree'  (p : (Omega3 S2pt).1) : U = Path (HopfTwo' (<_ _> base2))
                                                     (transGen (<k> HopfTwo' (p @ k)) 0 HopfTwo'pt)  HopfTwo'pt


-- Hardcode the simplest thing possible:
HopfThree''  (p : (Omega3 S2pt).1) : U =
  Path (Path loopS1 (<_> base1) (<_> base1)) (<_ _> base1)  (<i j> transGen (<k> Hopf (p @ i @ j @ k)) 0 base1)

-- This is now trivial!
truncFibOmega' (n : nat) (B : ptType) (P : B.1 -> U) (f : P (pt B))
  (tr : inhOrTrunc (P (pt B)) (suc n)) (p : (Omega B).1) : inhOrTrunc (fibOmega' B P f p) n = tr (subst B.1 P (pt B) (pt B) p f) f

unprime (B : ptType) (P : B.1 -> U) (f : P (pt B)) (p : (Omega B).1) (x : fibOmega' B P f p) : fibOmega B P f p
 = <i> hcomp (P (p @ i)) (transGen (<l> P (p @ (-l \/ i))) 0 (x @ i))
             [ (i = 0) -> <k> transGen (<l> P (p @ (-l /\ -k))) k (transGen (<l> P (p @ (l /\ -k))) k f)
             , (i = 1) -> <k> transGen (<_> P (pt B)) k f]

unprimePt (B : ptType) (P : B.1 -> U) (f : P (pt B))
  : Path (fibOmega B P f (<_> pt B)) (unprime B P f (<_> pt B) (<i> transGen (<_> P (pt B)) i f))
                                     (<_> f)
 = <k> <i> hcomp (P (pt B))
                 (hfill (P (pt B)) (transGen (<_> P (pt B)) k (transGen (<_> P (pt B)) (i \/ k) f))
                        [(i=0) -> <j> transGen (<_> P (pt B)) (j \/ k) (transGen (<_> P (pt B)) (j \/ k) f)
                        ,(i=1) -> <j> transGen (<_> P (pt B)) (j \/ k) f] @ -k)
                 [(i=0) -> <j> transGen (<_> P (pt B)) (-k \/ k \/ j) (transGen (<_> P (pt B)) (-k \/ k \/ j) f)
                 ,(i=1) -> <j> transGen (<_> P (pt B)) (-k \/ k \/ j) f
                 ,(k=0) -> <_> (unprime B P f (<_> pt B) (<i> transGen (<_> P (pt B)) i f) @ i)
                 ,(k=1) -> <_> f
                 ]

unprimeOne (p : (Omega S2pt).1) (q : HopfOne' p) : HopfOne p =
  unprime S2pt Hopf base1 p q

unprimeTwoFst (p : (Omega2 S2pt).1) (q : HopfTwo' p) : fibOmega (Omega S2pt) HopfOne' (<_> base1) p =
  unprime (Omega S2pt) HopfOne' (<_> base1) p q

unprimeTwoSnd (p : (Omega2 S2pt).1) (q : fibOmega (Omega S2pt) HopfOne' (<_> base1) p) : HopfTwo p
 = <i> hcomp (fibOmega S2pt Hopf base1 (p @ i)) (unprime S2pt Hopf base1 (p @ i) (q @ i))
             [ (i=0) -> unprimePt S2pt Hopf base1
             , (i=1) -> unprimePt S2pt Hopf base1]

unprimeTwo (p : (Omega2 S2pt).1) (q : HopfTwo' p) : HopfTwo p =
  unprimeTwoSnd p (unprimeTwoFst p q)

unprimeThreeFst (p : (Omega3 S2pt).1) (q : HopfThree' p) : fibOmega (Omega2 S2pt) HopfTwo' HopfTwo'pt p =
  unprime (Omega2 S2pt) HopfTwo' HopfTwo'pt p q

unprimeThreeSnd (p : (Omega3 S2pt).1) (q : fibOmega (Omega2 S2pt) HopfTwo' HopfTwo'pt p) : fibOmega (Omega2 S2pt) (fibOmega (Omega S2pt) HopfOne' (<_> base1)) (<_ _> base1) p =
  <i> hcomp (fibOmega (Omega S2pt) HopfOne' (<_> base1) (p @ i)) (unprime (Omega S2pt) HopfOne' (<_> base1) (p @ i) (q @ i))
            [ (i=0) -> unprimePt (Omega S2pt) HopfOne' (<_> base1)
            , (i=1) -> unprimePt (Omega S2pt) HopfOne' (<_> base1)]

unprimeThreeTrd (p : (Omega3 S2pt).1) (q : fibOmega (Omega2 S2pt) (fibOmega (Omega S2pt) HopfOne' (<_> base1)) (<_ _> base1) p) : HopfThree p =
  <i j> hcomp (HopfOne (p @ i @ j)) (unprime S2pt Hopf base1 (p @ i @ j) (q @ i @ j))
              [(j=0) -> unprimePt S2pt Hopf base1
              ,(j=1) -> unprimePt S2pt Hopf base1
              ,(i=0) -> unprimePt S2pt Hopf base1
              ,(i=1) -> unprimePt S2pt Hopf base1
              ]

unprimeThree (p : (Omega3 S2pt).1) (q : HopfThree' p) : HopfThree p =
  unprimeThreeTrd p (unprimeThreeSnd p (unprimeThreeFst p q))

{-
Unfinished attempt to define unprimeThree directly, doesn't seem easy

unprimeThree' (p : (Omega3 S2pt).1) (q : HopfThree' p) : HopfThree p =
  <i j k> hcomp (Hopf (p @ i @ j @ k)) (transGen (<l> Hopf (p @ (i \/ -l) @ (j \/ -l) @ (k \/ -l))) 0 (q @ i @ j -- @ k))
                [(k=0) -> <m> transGen (<l> Hopf (p @ (i \/ -l) @ (j \/ -l) @ (k \/ -(l \/ m)))) m (q @ i @ j @ k-- )
                ,(k=1) -> <_> q @ i @ j @ k
                ,(j=0) -> <m> transGen (<l> Hopf (p @ (i \/ -l) @ (j \/ -(l \/ m)) @ (k \/ -l))) m (q @ i @ j @ k-- )
                ]
-}

-- end of alternative attempt

-- transport doens't give something simpler:
-- truncFibOmega0 (B : ptType) (P : B.1 -> U) (f : P (pt B))
--   (tr : (x y : P (pt B)) -> Path (P (pt B)) x y) (p : (Omega B).1) : fibOmega B P f p =
--   let trf : Path (P B.2) (subst B.1 P (pt B) (pt B) p f) f =
--         tr (subst B.1 P (pt B) (pt B) p f) f
--       eq : Path U (Path (P (pt B)) (subst B.1 P (pt B) (pt B) p f) f)
--                   (PathP (<i> P (p @ i)) f f) =
--                     <i> funDepTr B.1 P (pt B) (pt B) p f f @ -i
--   in transport eq trf

-------
-- We now need that S1 is a groupoid

-- I now do this by proving that loopS1 is a retract of Z, as Z is a
-- set this is also set. Previously the proof transported the proof
-- that Z is a set to loopS1 along the equivalence loopS1 ~= Z,
-- hopefully this proof will compute faster.

-- This not needed!
-- loopS1equalsZ : Path U loopS1 Z =
--   isoPath loopS1 Z (encode base) (decode base) decodeEncodeBase (encodeDecode base)

data N0 =

not (A : U) : U = A -> N0
efq (A : U) : N0 -> A = split {}

-- Direct proof that Z is a set:
-- This seems to compute worse than the version with Hedberg, see comment below
invP : (n m : nat) (p : Path nat n m) -> U = split
  zero  -> split@((m : nat) (p : Path nat zero m) -> U) with
    zero  -> \(p : Path nat zero zero) ->
               Path (Path nat zero zero) p (<_> zero)
    suc m -> \(p : Path nat zero (suc m)) -> N0
  suc n -> split@((m : nat) (p : Path nat (suc n) m) -> U) with
    zero  -> \(p : Path nat (suc n) zero) -> N0
    suc m -> \(p : Path nat (suc n) (suc m)) ->
               Path (Path nat (suc n) (suc m)) p (<i> suc (pred (p @ i)))

-- using J for now
pinv : (n m : nat) (p : Path nat n m) -> invP n m p = split
  zero  -> J nat zero (invP zero) (<_ _> zero)
  suc n -> J nat (suc n) (invP (suc n)) (<_ _> suc n)

lem : (n : nat) (p : Path nat n n) -> Path (Path nat n n) p (<_> n) = split
  zero  -> pinv zero zero
  suc n -> \(p : Path nat (suc n) (suc n)) ->
               compPath (Path nat (suc n) (suc n)) p (<i> suc (pred (p @ i))) (<_> suc n)
                 (pinv (suc n) (suc n) p)
                 (<i j> suc (lem n (<k> pred (p @ k)) @ i @ j))

natset' (n : nat) : (m : nat) (p q : Path nat n m) -> Path (Path nat n m) q p =
  J nat n (\(m : nat)(p : Path nat n m) ->
            (q : Path nat n m) -> Path (Path nat n m) q p)
    (lem n)

setnat (n m : nat) (p q : Path nat n m) : Path (Path nat n m) p q = natset' n m q p

invZ : (u v : Z) (p : Path Z u v) -> U = split
  pos a -> split@((v : Z) -> (p : Path Z (pos a) v) -> U) with
    pos a' -> \(p : Path Z (pos a) (pos a')) ->
              (q : Path nat a a') * (Path (Path Z (pos a) (pos a')) p (<i> pos (q @ i)))
    neg b' -> \(p : Path Z (pos a) (neg b')) -> N0
  neg b -> split@((v : Z) -> (p : Path Z (neg b) v) -> U) with
    pos a' -> \(p : Path Z (neg b) (pos a')) -> N0
    neg b' -> \(p : Path Z (neg b) (neg b')) ->
              (q : Path nat b b') * (Path (Path Z (neg b) (neg b')) p (<i> neg (q @ i)))

pinvZ : (u v : Z) (p : Path Z u v) -> invZ u v p = split
  pos a -> J Z (pos a) (invZ (pos a)) (<_> a,<_ _> pos a)
  neg b -> J Z (neg b) (invZ (neg b)) (<_> b,<_ _> neg b)

lemZ : (u : Z) (p : Path Z u u) -> Path (Path Z u u) p (<_> u) = split
  pos a -> \(p : Path Z (pos a) (pos a)) ->
    let qa : invZ (pos a) (pos a) p = pinvZ (pos a) (pos a) p
    in compPath (Path Z (pos a) (pos a)) p (<i> pos (qa.1 @ i)) (<_> pos a) qa.2
                (<i j> pos (setnat a a qa.1 (<_> a) @ i @ j))
  neg b -> \(p : Path Z (neg b) (neg b)) ->
    let qb : invZ (neg b) (neg b) p = pinvZ (neg b) (neg b) p
    in compPath (Path Z (neg b) (neg b)) p (<i> neg (qb.1 @ i)) (<_> neg b) qb.2
                (<i j> neg (setnat b b qb.1 (<_> b) @ i @ j))

setZ' (u : Z) : (v : Z) (p q : Path Z u v) -> Path (Path Z u v) q p =
  J Z u (\(v : Z) (p : Path Z u v) -> (q : Path Z u v) -> Path (Path Z u v) q p)
    (lemZ u)

-- This version seems to compute bad! Try
-- > setLoop (<_> base1) (transGen (<_> loopS1) 0 (<_> base1)) (<i> hfill loopS1 (<_> base1) [] @ i) (arg4 test0To4)
-- with arg4 opaque!
-- ZSet (u v : Z) (p q : Path Z u v) : Path (Path Z u v) p q = setZ' u v q p


-- Z is a set using Hedberg
data or (A B : U) = inl (a : A)
                  | inr (b : B)

data Unit = tt

stable (A : U) : U = not (not A) -> A
const (A : U) (f : A -> A) : U = (x y : A) -> Path A (f x) (f y)

exConst (A : U) : U = (f:A -> A) * const A f
propN0 : prop N0 = \ (x y:N0) -> efq (Path N0 x y) x

propNot (A : U) : prop (not A) = \ (f g:not A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

dNot (A : U) (a : A) : not (not A) = \ (h : not A) -> h a

stableConst (A : U) (sA : stable A) : exConst A =
 (\ (x:A) -> sA (dNot A x),\ (x y:A) -> <i>sA (propNot (not A) (dNot A x) (dNot A y) @ i))

dec (A : U) : U = or A (not A)

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A : U) : dec A -> stable A = split
 inl a -> \ (h :not (not A)) -> a
 inr b -> \ (h :not (not A)) -> efq A (h b)

discrete (A : U) : U = (a b : A) -> dec (Path A a b)

hedbergLemma (A: U) (a b:A) (f : (x : A) -> Path A a x -> Path A a x) (p : Path A a b) :
            Square A a a a b (<_> a) p (f a (<_> a)) (f b p) = <i> f (p @ i) (<j> p @ i /\ j)

hedbergStable (A : U) (a b : A) (h : (x : A) -> stable (Path A a x))
        (p q : Path A a b) : Path (Path A a b) p q = 
 <j i> hcomp A a [ (j = 0) -> rem2 @ i
                 , (j = 1) -> rem3 @ i
                 , (i = 0) -> r
                 , (i = 1) -> rem4 @ j]
 where
   rem1 (x : A) : exConst (Path A a x) = stableConst (Path A a x) (h x)
   f (x : A) : Path A a x -> Path A a x  = (rem1 x).1
   fIsConst (x : A) : const (Path A a x) (f x) = (rem1 x).2
   rem4 : Square A a a b b (<_> a) (<_> b) (f b p) (f b q)  = fIsConst b p q
   r : Path A a a = f a (<_> a)
   rem2 : Square A a a a b (<_> a) p r (f b p) = hedbergLemma A a b f p
   rem3 : Square A a a a b (<_> a) q r (f b q) = hedbergLemma A a b f q

hedbergS (A : U) (h : (a x : A) -> stable (Path A a x)) : set A =
 \(a b : A) -> hedbergStable A a b (h a)

hedberg (A : U) (h : discrete A) : set A =
 \(a b : A) -> hedbergStable A a b (\(b : A) -> decStable (Path A a b) (h a b))

caseNat (A : U) (a0 aS : A) : nat -> A = split
 zero -> a0
 suc n -> aS

caseDNat (P:nat -> U) (a0 :P zero) (aS : (n:nat) -> P (suc n))
            : (n:nat) -> P n = split
 zero -> a0
 suc n -> aS n

znots (n : nat) : not (Path nat zero (suc n)) =
  \(h : Path nat zero (suc n)) -> subst nat (caseNat U nat N0) zero (suc n) h zero

snotz (n : nat) : not (Path nat (suc n) zero) =
  \(h : Path nat (suc n) zero) -> znots n (<i> h @ -i)

sucInj (n m : nat) (p : Path nat (suc n) (suc m)) : Path nat n m =
 <i> pred (p @ i)

discreteNat : discrete nat = split
 zero -> caseDNat (\(m : nat) -> dec (Path nat zero m)) (inl (<_> zero)) (\(m : nat) -> inr (znots m))
 suc n -> caseDNat (\(m : nat) -> dec (Path nat (suc n) m)) (inr (snotz n))
   (\(m : nat) -> decEqCong (Path nat n m) (Path nat (suc n) (suc m)) (\(p : Path nat n m) -> <i> suc (p @ i))
                  (sucInj n m) (discreteNat n m))

posNotneg (a b : nat) (h : Path Z (pos a) (neg b)) : N0 = subst Z T (pos a) (neg b) h tt
  where
  T : Z -> U = split
       pos _ -> Unit
       neg _ -> N0

negNotpos (a b : nat) (h : Path Z (neg b) (pos a)) : N0 = subst Z T (neg b) (pos a) h tt
  where
  T : Z -> U = split
       pos _ -> N0
       neg _ -> Unit

injPos (a b : nat) (h : Path Z (pos a) (pos b)) : Path nat a b =
 subst Z T (pos a) (pos b) h (<_> a)
 where
   T : Z -> U = split
        pos c -> Path nat a c
        neg _ -> N0

injNeg (a b : nat) (h : Path Z (neg a) (neg b)) : Path nat a b =
  subst Z T (neg a) (neg b) h (<_> a)
  where
    T : Z -> U = split
         pos _ -> N0
         neg c -> Path nat a c

discreteZ : discrete Z = split
  pos a -> split@((z1 : Z) -> dec (Path Z (pos a) z1)) with
             pos a1 -> let rem : dec (Path nat a a1) -> dec (Path Z (pos a) (pos a1)) = split
                             inl p -> inl (<i> pos (p @ i))
                             inr h -> inr (\(p : Path Z (pos a) (pos a1)) -> h (injPos a a1 p))
                       in rem (discreteNat a a1)
             neg b -> inr (posNotneg a b)
  neg b -> split@((z1 : Z) -> dec (Path Z (neg b) z1)) with
             pos a -> inr (negNotpos a b)
             neg b1 -> let rem : dec (Path nat b b1) -> dec (Path Z (neg b) (neg b1)) = split
                             inl p -> inl (<i> neg (p @ i))
                             inr h -> inr (\(p : Path Z (neg b) (neg b1)) -> h (injNeg b b1 p))
                       in rem (discreteNat b b1)

ZSet : set Z = hedberg Z discreteZ

-- No need for substituting in the universe here
-- setLoop : set loopS1 = subst U set Z loopS1 (<i> loopS1equalsZ @ -i) ZSet

predZ : Z -> Z = split
  pos u -> auxpredZ u
    where
    auxpredZ : nat -> Z = split
      zero  -> neg zero
      suc n -> pos n
  neg v -> neg (suc v)

sucZ : Z -> Z = split
  pos u -> pos (suc u)
  neg v -> auxsucZ v
    where
    auxsucZ : nat -> Z = split
      zero  -> pos zero
      suc n -> neg n

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  pos u -> <_> pos u
  neg v -> lem v
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (neg u))) (neg u) = split
      zero  -> <_> neg zero
      suc n -> <_> neg (suc n)

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  pos u -> lem u
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (pos u))) (pos u) = split
      zero  -> <_> pos zero
      suc n -> <_> pos (suc n)
  neg v -> <_> neg v

-- alternative proof that sucZ is an equiv, not using the "grad lemma"

-- Maybe we can generalize the notion of being a set to allow
-- arbitrary paths on the sides and not just refl?
gengoal (A : U) (hA : set A) (x y : A) (p : Path A x y) : (z : A) (r : Path A y z) (q : Path A x z) ->
  PathP (<i> Path A x (r @ i)) p q =
  J A y (\(z : A) (r : Path A y z) -> (q : Path A x z) -> PathP (<i> Path A x (r @ i)) p q)
   (hA x y p)

ctr (y : Z) : fiber Z Z sucZ y = (predZ y,<i> sucpredZ y @ -i)

contr (y : Z) (y' : fiber Z Z sucZ y) : Path ((x : Z) * Path Z y (sucZ x)) (ctr y) y' =
    let p1 : Path Z (predZ y) y'.1 =
          compPath Z (predZ y) (predZ (sucZ y'.1)) y'.1
                   (<i> predZ (y'.2 @ i)) (predsucZ y'.1)
        prf1 : Path Z (sucZ (predZ y)) (sucZ y'.1) = <i> sucZ (p1 @ i)
        prf2 : Path Z y (sucZ (predZ y)) = <i> sucpredZ y @ -i
        p2 : PathP (<i> Path Z y (prf1 @ i)) prf2 y'.2 =
          gengoal Z ZSet y (sucZ (predZ y)) prf2 (sucZ y'.1) prf1 y'.2
    in <i> (p1 @ i,p2 @ i)

equivSucZ : isEquiv Z Z sucZ = \(y : Z) -> (ctr y,contr y)

sucPathZ : Path U Z Z = ua Z Z (sucZ,equivSucZ)

-- Old version using "grad lemma":
-- sucPathZ : Path U Z Z = isoPath Z Z sucZ predZ sucpredZ predsucZ

-- We now prove that "decode x (encode x p) = p" so that we get that
-- loopS1 is a retract of Z

-- Below is a direct definition of decode:

-- Covering space of the circle
helix : S1 -> U = split
  base1 -> Z
  loop1 @ i -> sucPathZ @ i

compS1 : loopS1 -> loopS1 -> loopS1 = compPath S1 base1 base1 base1
invLoop : loopS1 = <i> loop @ -i

encode (x : S1) (p : Path S1 base1 x) : helix x =
  subst S1 helix base1 x p zeroZ

-- loop^n
loopPos : nat -> loopS1 = split
  zero -> <_> base1
  suc n -> compS1 (loopPos n) loop

loopNeg : nat -> loopS1 = split
  zero -> invLoop
  suc n -> compS1 (loopNeg n) invLoop

loopIt : Z -> loopS1 = split
  pos n -> loopPos n
  neg n -> loopNeg n


decodeSquarePos : (n : nat) -> Square S1 base1 base1 base1 base1
                                      (<_> base1)
                                      loop
                                      (loopIt (predZ (pos n)))
                                      (loopIt (pos n)) = split
  zero -> <i j> loop @ i \/ -j
  suc n -> <i j> hfill S1 (loopPos n @ j) [ (j = 0) -> <_> base1
                                          , (j = 1) -> loop ] @ i

decodeSquareNeg (n : nat) : Square S1 base1 base1 base1 base1
                                   (<_> base1)
                                   loop
                                   (loopIt (predZ (neg n)))
                                   (loopIt (neg n)) =
  <i j> hcomp S1 (loopNeg n @ j)
                 [ (i=1) -> <_> loopNeg n @ j
                 , (j=0) -> <_> base1
                 , (j=1) -> <k> loop @ i \/ -k ]

decodeSquare : (n : Z) -> Square S1 base1 base1 base1 base1
                                 (<_> base1)
                                 loop
                                 (loopIt (predZ n))
                                 (loopIt n) = split
  pos n -> decodeSquarePos n
  neg n -> decodeSquareNeg n


decode : (x : S1) -> helix x -> Path S1 base1 x = split
  base1 -> loopIt
  loop1 @ i -> \(y : sucPathZ @ i) -> <j>
    let n : Z = unglue y Z [(i=0) -> (Z,(sucZ,equivSucZ))
                           ,(i=1) -> (Z,idEquiv Z)]
    in hcomp S1 (decodeSquare n @ i @ j)
                [ (j=0) -> <_> base1
                , (j=1) -> <_> loop @ i
                , (i=0) -> <k> loopIt (predsucZ y @ k) @ j
                , (i=1) -> <_> loopIt y @ j ]


-- Old version of decode:

-- shiftPos : (n : nat) -> Path loopS1 (compS1 (loopIt (predZ (pos n))) loop) (loopIt (pos n)) = split
--   zero -> compInvPath S1 base1 base1 loop
--   suc n -> <_ i> hcomp S1 (loopPos n @ i) [ (i = 0) -> <_> base1, (i = 1) -> loop ]

-- shiftNeg (n : nat) : Path loopS1 (compS1 (loopIt (predZ (neg n))) loop) (loopIt (neg n)) =
--   <j i> hcomp S1 (hfill S1 (loopNeg n @ i) [ (i = 0) -> <_> base1, (i = 1) -> <j> loop @ -j ] @ -j)
--                   [ (i = 0) -> <_> base1
--                   , (i = 1) -> <k> loop @ j \/ k
--                   , (j = 1) -> <k> loopNeg n @ i ]

-- -- it is important that the loop is appended as this is what the subst will do below
-- shift : (n : Z) -> Path loopS1 (compS1 (loopIt (predZ n)) loop) (loopIt n) = split
--   pos n -> shiftPos n
--   neg n -> shiftNeg n

-- -- -- Compose 3 paths. This is a little bit more compact than doing 2 compPath
-- -- comp3 (A : U) (a b c d : A) (p : Path A a b) (q : Path A b c) (r : Path A c d) : Path A a d =
-- --   <i> hcomp A (q @ i) [ (i = 0) -> <j> p @ -j, (i = 1) -> r ]

-- hcompbase (p : loopS1) : loopS1 =
--   <i> hcomp S1 (p @ i) [ (i = 0) -> <_> base1, (i = 1) -> <_> base1 ]

-- hcompbaseeq (p : loopS1) : Path loopS1 (hcompbase p) p =
--   <j i> hcomp S1 (p @ i /\ -j) [ (i = 0) -> <_> base1
--                                , (i = 1) -> <k> p @ -j \/ k
--                                , (j = 1) -> <k> p @ i /\ k ]

-- -- -- This is quite ugly, but we need to remove 4 hcomp's with base on both sides...
-- -- hcompbaseeq4 (p : loopS1) : Path loopS1 (hcompbase (hcompbase (hcompbase (hcompbase p)))) p =
-- --   let sq1 : Path loopS1 (hcompbase p) p = hcompbaseeq p
-- --       sq2 : Path loopS1 (hcompbase (hcompbase p)) (hcompbase p) =
-- --               hcompbaseeq (hcompbase p)
-- --       sq3 : Path loopS1 (hcompbase (hcompbase (hcompbase p))) (hcompbase (hcompbase p)) =
-- --               hcompbaseeq (hcompbase (hcompbase p))
-- --       sq4 : Path loopS1 (hcompbase (hcompbase (hcompbase (hcompbase p)))) (hcompbase (hcompbase (hcompbase p))) =
-- --               hcompbaseeq (hcompbase (hcompbase (hcompbase p)))
-- --   in compPath loopS1
-- --        (hcompbase (hcompbase (hcompbase (hcompbase p)))) (hcompbase (hcompbase (hcompbase p))) p sq4
-- --        (<i> hcomp loopS1 (sq2 @ i) [ (i = 0) -> <j> sq3 @ -j, (i = 1) -> sq1 ])

-- hcompbaseeq2 (p : loopS1) : Path loopS1 (hcompbase (hcompbase p)) p =
--   let sq1 : Path loopS1 (hcompbase p) p = hcompbaseeq p
--       sq2 : Path loopS1 (hcompbase (hcompbase p)) (hcompbase p) =
--               hcompbaseeq (hcompbase p)
--   in compPath loopS1 (hcompbase (hcompbase p)) (hcompbase p) p sq2 sq1

-- -- This proof requires that "transGen (<_> nat) 0 n == n" judgmentally as it is done now
-- -- This proof requires that "transGen (<_> S1) 0 n == n" judgmentally as it is done now
-- decodeLoop (n : Z) :
--   Path (Path S1 base1 base1)
--   (subst S1 (\(x : S1) -> helix x -> Path S1 base1 x) base1 base1 loop loopIt n)
--   (loopIt n) =
--       let T (p : loopS1) : loopS1 =
--             (<i> hcomp S1 (hcomp S1 (hcomp S1 (p @ i)
--                                               [ (i = 0) -> <_> base1
--                                               , (i = 1) -> <_> base1 ])
--                                     [ (i = 0) -> <_> base1
--                                    , (i = 1) -> <_> base1 ])
--                           [ (i = 0) -> <_> base1
--                           , (i = 1) -> loop ])
                      
--           key (p : loopS1) : Path loopS1 (T p) (compS1 p loop) =
--             <i> compS1 (hcompbaseeq2 p @ i) loop

--           goal : Path loopS1 (T (loopIt (predZ n))) (loopIt n) =
--                       compPath loopS1 (T (loopIt (predZ n)))
--                         (compS1 (loopIt (predZ n)) loop) (loopIt n)
--                         (key (loopIt (predZ n))) (shift n)
--       in goal

-- decode : (x : S1) -> helix x -> Path S1 base1 x =
--   s1elim (\(x : S1) -> helix x -> Path S1 base1 x) loopIt (<i> \(x : Z) -> decodeLoop x @ i)

-- End of first old definition of decode

-- Old version of decode:

-- Maybe put l in the end?
-- oneTurn (l : loopS1) : loopS1 = compS1 l loop
-- backTurn (l : loopS1) : loopS1 = compS1 l invLoop

-- itLoop : nat -> loopS1 = split
--  zero -> <_> base1
--  suc n -> oneTurn (itLoop n)

-- itLoopNeg : nat -> loopS1 = split
--  zero -> invLoop
--  suc n -> backTurn (itLoopNeg n)

-- -- Maybe don't compose with <_> base1 in the positive case?
-- loopIt : Z -> loopS1 = split
--  pos n -> itLoop n
--  neg n -> itLoopNeg n

-- lem1ItPos : (n : nat) -> Path loopS1 (loopIt (sucZ (pos n))) (oneTurn (loopIt (pos n))) = split
--  zero -> <_> oneTurn (<_> base1)
--  suc p -> <i> oneTurn (lem1ItPos p @ i)

-- -- todo: clean
-- compInv (A:U) (a:A) : (x:A) (p:Path A a x) -> Path (Path A x x) (<_>x) (compPath A x a x (<i>p@-i) p) =
--  J A a (\  (x:A) (p:Path A a x) -> Path (Path A x x) (<_>x) (compPath A x a x (<i>p@-i) p)) rem
--  where rem : Path (Path A a a) (<_>a) (<i>hcomp A a [(i=0) -> <_>a,(i=1) -> <_>a]) =
--         <j i>hcomp A a [(j=0) -> <_>a,(i=0) -> <_>a,(i=1) -> <_>a]

-- compInvS1 : Path loopS1 (<_> base1) (compS1 invLoop loop) = compInv S1 base1 base1 loop

-- -- todo: why this one with the same name? clean!
-- compInv (A:U) (a b:A) (q:Path A a b) : (x:A) (p:Path A b x) -> Path (Path A a b) q (compPath A a x b (compPath A a b x q p) (<i>p@-i)) =
--  J A b (\ (x:A) (p:Path A b x) -> Path (Path A a b) q (compPath A a x b (compPath A a b x q p) (<i>p@-i))) rem
--  where rem : Path (Path A a b) q
--                            (<i>hcomp A (hcomp A (q@i) [(i=0) -> <_>a,(i=1) -> <_>b]) [(i=0) -> <_>a,(i=1) -> <_>b]) =
--           <j i>hcomp A (hcomp A (q@i) [(j=0) -> <_>q@i,(i=0) -> <_>a,(i=1) -> <_>b]) [(j=0) -> <_>q@i,(i=0) -> <_>a,(i=1) -> <_>b]

-- lem1ItNeg : (n:nat) -> Path loopS1 (loopIt (sucZ (neg n))) (oneTurn (loopIt (neg n))) = split
--  zero -> compInvS1
--  suc p -> compInv S1 base1 base1 (loopIt (neg p)) base1 invLoop

-- -- shift : (n : Int) -> (loop o (loop^ (pred n))) = loop^ n
-- -- is not the same as:
-- lem1It : (n:Z) -> Path loopS1 (loopIt (sucZ n)) (oneTurn (loopIt n)) = split
--   pos n -> lem1ItPos n
--   neg n -> lem1ItNeg n

-- lemFib1 (A:U) (F G : A -> U) (a:A) (fa : F a -> G a) :
--    (x:A) (p : Path A a x) -> (fx : F x -> G x) ->
--      Path U (Path (F a -> G x) (\(u : F a) -> subst A G a x p (fa u))
--                                (\(u : F a) -> fx (subst A F a x p u)))
--             (PathP (<i> F (p @ i) -> G (p @ i)) fa fx) =
--   J A a (\(x : A) (p : Path A a x) -> (fx : F x -> G x) ->
--      Path U (Path (F a -> G x) (\(u : F a) -> subst A G a x p (fa u))
--                                (\(u : F a) -> fx (subst A F a x p u)))
--             (PathP (<i>F (p@i) -> G (p@i)) fa fx)) rem
--   where
--   rem (ga : F a -> G a) :
--     Path U (Path (F a -> G a) (\(u : F a) -> transGen (<_> G a) 0 (fa u))
--                               (\(u : F a) -> ga (transGen (<_> F a) 0 u)))
--            (PathP (<_> F a -> G a) fa ga) =
--       <j> Path (F a -> G a) (\(u : F a) -> lemTransGen0 (G a) (fa u) @ j)
--                             (\(u : F a) -> ga (lemTransGen0 (F a) u @ j))

-- corFib1 (A:U) (F G : A -> U) (a:A) (fa ga : F a -> G a) (p:Path A a a)
--   (h : (u:F a) -> Path (G a) (subst A G a a p (fa u)) (ga (subst A F a a p u))) :
--   PathP (<i> F (p @ i) -> G (p @ i)) fa ga =
--     comp (lemFib1 A F G a fa a p ga) (<i> \(u : F a) -> h u @ i) []

-- testHelix : Path (Z->Z) sucZ (subst S1 helix base1 base1 loop) =
--   let rem (x : Z) : Path Z (sucZ x) (hcomp Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) []) =
--         compPath Z (sucZ x)
--                    (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) [])
--                    (hcomp Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) [])
--                    (fill (<_> Z) (sucZ x) [])
--                    (hfill Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) [])
--   in <i> \(x : Z) -> rem x @ i

-- decode : (x:S1) -> helix x -> Path S1 base1 x = split
--   base1 -> loopIt
--   loop1 @ i -> rem @ i
--    where
--    T : U = Z -> loopS1
--    G (x:S1) : U =  Path S1 base1 x
--    p : Path U T T = <j> helix (loop @ j) -> Path S1 base1 (loop@j)
--    rem2 (x:Z) :
--       Path loopS1 (oneTurn (loopIt x))
--                   (loopIt (sucZ x)) = <i> lem1It x @ -i
--    rem4 (x : Z) : Path (Path S1 base1 base1)
--         (<i> hcomp S1 (transGen0 S1 (loopIt x @ i))
--                        [ (i = 0) -> <_> base1
--                        , (i = 1) -> loop ])
--         (<i> hcomp S1 (loopIt x @ i)
--                        [ (i = 0) -> <_> base1
--                        , (i = 1) -> loop ]) = <j i> hcomp S1 (transGen (<_> S1) j (loopIt x @ i)) [ (i = 0) -> <_> base1, (i = 1) -> loop ]
--    rem3 (x : Z) :
--      Path loopS1 (subst S1 G base1 base1 loop (loopIt x))
--                  (loopIt (sucZ x)) =
--        compPath loopS1 (subst S1 G base1 base1 loop (loopIt x))
--          (oneTurn (loopIt x)) (loopIt (sucZ x))
--          (rem4 x) (rem2 x)
--    rem1 (x:Z) : Path loopS1 (subst S1 G base1 base1 loop (loopIt x))
--                            (loopIt (subst S1 helix base1 base1 loop x)) =
--     comp (<i> Path loopS1 (subst S1 G base1 base1 loop (loopIt x))
--                           (loopIt (testHelix @ i x))) (rem3 x) []
--    rem : PathP p loopIt loopIt = corFib1 S1 helix G base1 loopIt loopIt loop rem1

-- End of second old version of decode

-- This is just J
decodeEncode (x : S1) (p : Path S1 base1 x) :
  Path (Path S1 base1 x) (decode x (encode x p)) p =
    transGen (<i> Path (Path S1 base1 (p @ i))
                       (decode (p @ i) (encode (p @ i) (<j> p @ i /\ j)))
                       (<j> p @ i /\ j))
              0
              (<_ _> base1)


-- Can this be simplified? YES! See below
-- decodeEncode' (x : S1) (p : Path S1 base1 x) :
--   Path (Path S1 base1 x) (decode x (encode x p)) p =
--   -- This is the normal form:
--   <i j> hcomp S1 (hcomp S1 base1 [ (j = 0) -> <_> base1
--                                  , (j = 1) -> p ])
--                  [ (i = 0) -> <k> hcomp S1 (decode (p @ k) (encode (p @ k) (<l> p @ k /\ l)) @ j)
--                                            [ (j = 0) -> <_> base1
--                                            , (j = 1) -> <l> p @ k \/ l
--                                            , (k = 1) -> <_> decode x (encode x p) @ j ]
--                  , (i = 1) -> <k> hcomp S1 (p @ j /\ k)
--                                            [ (j = 0) -> <_> base1
--                                            , (j = 1) -> <l> p @ k \/ l
--                                            , (k = 1) -> <_> p @ j ]
--                  , (j = 0) -> <_> base1
--                  , (j = 1) -> <_> x ]

-- This is the new normal form after making comp compute directly for Path and Sigma
decodeEncode'' (x : S1) (p : Path S1 base1 x) :
  Path (Path S1 base1 x) (decode x (encode x p)) p =
  <i j> hcomp S1 base1 [ (i = 0) -> <k> decode (p @ k) (encode (p @ k) (<l> p @ (k /\ l))) @ j
                       , (i = 1) -> <k> p @ (j /\ k)
                       , (j = 0) -> <k> base1
                       , (j = 1) -> p ]


decodeEncodeRefl : Path loopS1 (decode base1 (encode base1 (<_> base1))) (<_> base1) =
  <_ _> base1

-- a retract of a set is also a retract
retract (A B : U) (f : A -> B) (g : B -> A) : U =
  (a : A) -> Path A (g (f a)) a

compUp (A : U) (a a' b b' : A) (p : Path A a a') (q : Path A b b')
  (r : Path A a b) : Path A a' b' =
    <i> hcomp A (r @ i) [(i = 0) -> p, (i = 1) -> q]

lemRetract (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (x y : A) : Path A (g (f x)) (g (f y)) -> Path A x y =
    compUp A (g (f x)) x (g (f y)) y (rfg x) (rfg y)

retractProp (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (pB : prop B) (x y : A) : Path A x y =
    lemRetract A B f g rfg x y (<i> g (pB (f x) (f y) @ i))

retractInv (A B : U)  (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (x y : A) (q : Path B (f x) (f y)) : Path A x y =
    <i> hcomp A (g (q @ i)) [(i = 0) -> rfg x, (i = 1) -> rfg y]

retractPath (A B : U)(f : A -> B) (g : B -> A) (rfg : retract A B f g) (x y :A) (p:Path A x y) :
  Path (Path A x y) (retractInv A B f g rfg x y (<i> f (p@ i))) p =
    <j i> hcomp A (rfg (p @ i) @ j)
       [ (i = 0) -> <k> rfg x @ (j \/ k)
       , (i = 1) -> <k> rfg y @ (j \/ k)
       , (j = 1) -> <k> rfg (p @ i) @ 1
       ]

retractSet (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
           (sB : set B) (x y : A) : prop (Path A x y) =
  retractProp (Path A x y) (Path B (f x) (f y)) (\(p : Path A x y) -> <i> f (p @ i))
              (retractInv A B f g rfg x y) (retractPath A B f g rfg x y) (sB (f x) (f y))

retractGroupoid (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
           (sB : groupoid B) (x y : A) : set (Path A x y) =
  retractSet (Path A x y) (Path B (f x) (f y)) (\(p : Path A x y) -> <i> f (p @ i))
              (retractInv A B f g rfg x y) (retractPath A B f g rfg x y) (sB (f x) (f y))

-- -- This calls decodeEncode 12 times
-- setLoop' : set loopS1 = retractSet loopS1 Z (encode base1) (decode base1) (decodeEncode base1) ZSet

-- This direct proof only calls decodeEncode 4 times:
setLoop (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s =
  let f : loopS1 -> Z = encode base1
      g : Z -> loopS1 = decode base1
  in <j i> hcomp loopS1 (g (ZSet (f p) (f q) (<i> f (r @ i)) (<i> f (s @ i)) @ j @ i))
                        [ (i = 0) -> decodeEncode base1 p
                        , (i = 1) -> decodeEncode base1 q
                        , (j = 0) -> decodeEncode base1 (r @ i)
                        , (j = 1) -> decodeEncode base1 (s @ i) ]

-- We actually never need the full isGroupoidS1 as setLoop suffices!

lemPropF (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a0 a1 :A)
         (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i> P (p @ i)) b0 b1 =
  <i> pP (p @ i) (transGen (<j> P (p @ i /\ j)) (-i) b0)
                 (transGen (<j> P (p @ i \/ -j)) i b1) @ i

lemPropFib (P : S1 -> U) (pP : (x : S1) -> prop (P x)) (bP : P base1) : (x : S1) -> P x = split
 base1 -> bP
 loop1 @ i -> lemPropF S1 P pP base1 base1 loop bP bP @ i

isGroupoidS1 : groupoid S1 = lem
 where
  lem2 : (y : S1) -> set (Path S1 base1 y)
    = lemPropFib (\(y : S1) -> set (Path S1 base1 y))
                 (\(y : S1) -> setIsProp (Path S1 base1 y))
                 setLoop

  lem : (x y : S1) -> set (Path S1 x y)
   = lemPropFib (\(x : S1) -> (y : S1) -> set (Path S1 x y)) pP lem2
     where
       pP (x : S1) : prop ((y : S1) -> set (Path S1 x y)) =
        propPi S1 (\(y : S1) -> set (Path S1 x y))
                  (\(y : S1) -> setIsProp (Path S1 x y))

one : nat = suc zero
two : nat = suc one

-- Obsolete now
-- -- I hardcode this as the smallest thing possible. The fact that we
-- -- are calling setLoop with refl should make it possible to simplify
-- -- it even further as decodeEncode with refl is proved by refl.

fibContrHopfThree (p : (Omega3 S2pt).1) : HopfThree p =
  truncFibOmega zero (Omega2 S2pt) HopfTwo (<_ _> base1)
    (truncFibOmega one (Omega S2pt) HopfOne (<_> base1)
      (truncFibOmega two S2pt Hopf base1 isGroupoidS1 (<_> base2)) (<_ _> base2)) p

fibContrHopfThree_unfolded (p : (Omega3 S2pt).1) : HopfThree p =
  let p1 : inhOrTrunc loopS1 two =
--          truncFibOmega two S2pt Hopf base1 isGroupoidS1 (<_> base2)
            setLoop

      p2 : inhOrTrunc (Path loopS1 (<_> base1) (<_> base1)) one =
             truncFibOmega one (Omega S2pt) HopfOne (<_> base1) p1 (<_ _> base2)

      -- unfolded p2... Why is this so complicated???
      p2' : (x y : Path loopS1 (<_> base1) (<_> base1)) ->
            Path (Path loopS1 (<_> base1) (<_> base1)) x y =
            transGen (<i> (x y : Path loopS1 (<j> hcomp S1 base1 [ (i=1) -> <_> base1
                                                                 , (j=0) -> <_> base1
                                                                 , (j=1) -> <_> base1 ])
                                             (<_> base1)) ->
                          Path (Path loopS1 (<j> hcomp S1 base1 [ (i=1) -> <_> base1
                                                                , (j=0) -> <_> base1
                                                                , (j=1) -> <_> base1 ])
                                            (<_> base1)) x y) 0
                    (setLoop (<k> hcomp S1 base1 [ (k=0) -> <_> base1
                                                 , (k=1) -> <_> base1 ])
                             (<_> base1))

      -- The following should work!
      p2'' : (x y : Path loopS1 (<_> base1) (<_> base1)) ->
            Path (Path loopS1 (<_> base1) (<_> base1)) x y = setLoop (<_> base1) (<_> base1)

      p3 : fibOmega (Omega2 S2pt) HopfTwo (<_ _> base1) p =
        truncFibOmega zero (Omega2 S2pt) HopfTwo (<_ _> base1) p2'' p

      -- Unfolded version of p3
      p3' : PathP (<i> PathP (<j> PathP (<k> Hopf (p @ i @ j @ k)) base1 base1) (<_> base1) (<_> base1)) (<_ _> base1) (<_ _> base1) =
        <i j k> hcomp (Hopf (p @ i @ j @ k))
                      (transGen (<l> Hopf (p @ (i \/ -l) @ j @ k)) 0
                                (p2'' (<m n> (transGen (<o> Hopf (p @ o @ m @ n)) 0 base1))
                                    (<_ _> base1) @ i @ j @ k))
                      [ (i=0) -> <m> transGen (<l> Hopf (p @ (-l /\ -m) @ j @ k)) m
                                                     (transGen (<n> Hopf (p @ (-m /\ n) @ j @ k)) 0 base1)
                      , (i=1) -> <_> base1
                      , (j=0) -> <_> base1
                      , (j=1) -> <_> base1
                      , (k=0) -> <_> base1
                      , (k=1) -> <_> base1 ]
  in p3'


arg4 (p : (Omega3 S2pt).1) : Path loopS1 (<_> base1) (transGen (<_> loopS1) 0 (<_> base1)) =
  transGen (<i> Path loopS1 (<_> base1)
                            (transGen (<j> Path S1 base1 (transGen (<k> Hopf (p @ i @ j @ k)) 0 base1))
                                      0 (<_> base1)))
           0 (<i> hfill loopS1 (<_> base1) [] @ i)

fibContrHopfThree' (p : (Omega3 S2pt).1) : HopfThree' p =
  -- setLoop (<_> base1)
  --         (transGen (<_> loopS1) 0 (<_> base1))
  --         (<i> hfill loopS1 (<_> base1) [] @ i)
  --         (arg4 p)
  truncFibOmega' zero (Omega2 S2pt) HopfTwo' HopfTwo'pt
    (truncFibOmega' one (Omega S2pt) HopfOne' (<_> base1) setLoop (<_ _> base2)) p

fibContrHopfThree'' (p : (Omega3 S2pt).1) : HopfThree'' p =
  setLoop (<_> base1)
          (<_> base1)
          (<_ _> base1)
          (<i j> transGen (<k> Hopf (p @ i @ j @ k)) 0 base1)

fibContrHopfThree_unprime (p : (Omega3 S2pt).1) : HopfThree p =
  unprimeThree p (fibContrHopfThree' p)

fibContrHopfThree_evan (p : (Omega3 S2pt).1) : HopfThree p =
  <i j k>
  hcomp
    (Hopf (p @ i @ j @ k))
    (transGen (<n> Hopf (p @ i @ j @ k /\ n)) (i \/ -i \/ j \/ -j \/ -k) base1)
    [ (i=0) -> <_> base1
    , (i=1) -> <_> base1
    , (j=0) -> <_> base1
    , (j=1) -> <_> base1
    , (k=0) -> <_> base1
    , (k=1) -> <m>
      setLoop (<_> base1) (<_> base1)
        (<i j> transGen (<n> Hopf (p @ i @ j @ n)) (i \/ -i \/ j \/ -j) base1)
        (<_ _> base1)
        @ m @ i @ j
    ]
  
-- -- end of alternative approach

-- The map h from 9.3
h (p : (Omega3 S2pt).1) : (Omega3 (joinpt S1pt S1)).1 =
  <i j k> tee (p @ i @ j @ k) (fibContrHopfThree_unprime p @ i @ j @ k)

-- Alternative definition of the h map using fibContrHopfThree_unfolded
h' (p : (Omega3 S2pt).1) : (Omega3 (joinpt S1pt S1)).1 =
  <i j k> tee (p @ i @ j @ k) (fibContrHopfThree_unfolded p @ i @ j @ k)

-- h (p : (Omega3 S2pt).1) : (Omega3 (joinpt S1pt S1)).1 =
--   <i j k> TotalHopf2toJoinS1S1 (p @ i @ j @ k) (fibContrHopfThree_evan p @ i @ j @ k)

--------------------------------------------------------------------------------
-- B.9 Going back to pi2(S2)

-- B.9.1 Truncations

-- We first define these directly and then using hub-and-spoke in
-- order to see which is the most efficient for computation.

-- 2-Groupoid truncation
data g2Trunc (A : U) =
    g2inc (a : A)
  | g2squashC (a b : g2Trunc A)
              (p q : Path (g2Trunc A) a b)
              (r s : Path (Path (g2Trunc A) a b) p q)
              (t u : Path (Path (Path (g2Trunc A) a b) p q) r s)
              <i j k l>
               [ (i=0) -> t @ j @ k @ l
               , (i=1) -> u @ j @ k @ l
               , (j=0) -> r @ k @ l
               , (j=1) -> s @ k @ l
               , (k=0) -> p @ l
               , (k=1) -> q @ l
               , (l=0) -> a
               , (l=1) -> b ]

g2Truncpt (A : ptType) : ptType = (g2Trunc A.1,g2inc (pt A))

g2TruncRec (A B : U) (bG : twogroupoid B) (f : A -> B) : g2Trunc A -> B = split
    g2inc a -> f a
    g2squashC a b p q r s t u @ i j k l ->
      bG (g2TruncRec A B bG f a)
         (g2TruncRec A B bG f b)
         (<m> g2TruncRec A B bG f (p @ m))
         (<m> g2TruncRec A B bG f (q @ m))
         (<m n> g2TruncRec A B bG f (r @ m @ n))
         (<m n> g2TruncRec A B bG f (s @ m @ n))
         (<m n o> g2TruncRec A B bG f (t @ m @ n @ o))
         (<m n o> g2TruncRec A B bG f (u @ m @ n @ o))
         @ i @ j @ k @ l

g2TruncTwoGroupoid (A : U) : twogroupoid (g2Trunc A) =
  \(a b : g2Trunc A) (p q : Path (g2Trunc A) a b)
   (r s : Path (Path (g2Trunc A) a b) p q)
   (t u : Path (Path (Path (g2Trunc A) a b) p q) r s) ->
    <i j k l> g2squashC{g2Trunc A} a b p q r s t u @ i @ j @ k @ l

-- We now prove the eliminator for 2-groupoid truncation. This would
-- be a lot nicer in a proper proof assistant...

lem0 (A : U) (P : A -> U) (gP : (x : A) -> twogroupoid (P x)) (a : A) :
  (u : Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) (<_ _> a))
  (v : Path (Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) (<_ _> a)) (<_ _ _> a) u)
  (a1 b1 : P a)
  (p1 q1 : Path (P a) a1 b1)
  (r1 s1 : Path (Path (P a) a1 b1) p1 q1)
  (t1 : Path (Path (Path (P a) a1 b1) p1 q1) r1 s1)
  (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
  PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1 =
  J (Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) (<_ _> a)) (<_ _ _> a)
    (\(u : Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) (<_ _> a))
      (v : Path (Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) (<_ _> a)) (<_ _ _> a) u) ->
      (a1 b1 : P a)
      (p1 q1 : Path (P a) a1 b1)
      (r1 s1 : Path (Path (P a) a1 b1) p1 q1)
      (t1 : Path (Path (Path (P a) a1 b1) p1 q1) r1 s1)
      (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
      PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1)
      (gP a)

lem1 (A : U) (P : A -> U) (gP : (x : A) -> twogroupoid (P x)) (a : A) :
  (s : Path (Path A a a) (<_> a) (<_> a))
  (t u : Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) s)
  (v : Path (Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) s) t u)
  (a1 b1 : P a)
  (p1 q1 : Path (P a) a1 b1)
  (r1 : Path (Path (P a) a1 b1) p1 q1)
  (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
  (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
  (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
  PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1 =
  J (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a)
    (\(s : Path (Path A a a) (<_> a) (<_> a))
      (t : Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) s) ->
      (u : Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) s)
      (v : Path (Path (Path (Path A a a) (<_> a) (<_> a)) (<_ _> a) s) t u)
      (a1 b1 : P a)
      (p1 q1 : Path (P a) a1 b1)
      (r1 : Path (Path (P a) a1 b1) p1 q1)
      (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
      (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
      (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
      PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1)
      (lem0 A P gP a)

lem2 (A : U) (P : A -> U) (gP : (x : A) -> twogroupoid (P x)) (a : A) :
  (q : Path A a a) (r s : Path (Path A a a) (<_> a) q)
  (t u : Path (Path (Path A a a) (<_> a) q) r s)
  (v   : Path (Path (Path (Path A a a) (<_> a) q) r s) t u)
  (a1 : P a) (b1 : P a)
  (p1 : Path (P a) a1 b1)
  (q1 : PathP (<i> P (q @ i)) a1 b1)
  (r1 : PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
  (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
  (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
  (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
  PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1 =
   J (Path A a a) (<_> a) (\(q : Path A a a) (r : Path (Path A a a) (<_> a) q) ->
                            (s : Path (Path A a a) (<_> a) q)
                            (t u : Path (Path (Path A a a) (<_> a) q) r s)
                            (v   : Path (Path (Path (Path A a a) (<_> a) q) r s) t u)
                            (a1 b1 : P a)
                            (p1 : Path (P a) a1 b1)
                            (q1 : PathP (<i> P (q @ i)) a1 b1)
                            (r1 : PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
                            (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
                            (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
                            (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
                            PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1) (lem1 A P gP a)

lem (A : U) (P : A -> U) (gP : (x : A) -> twogroupoid (P x)) (a : A) :
    (b : A) (p q : Path A a b)
    (r s : Path (Path A a b) p q)
    (t u : Path (Path (Path A a b) p q) r s)
    (v   : Path (Path (Path (Path A a b) p q) r s) t u)
    (a1 : P a) (b1 : P b)
    (p1 : PathP (<i> P (p @ i)) a1 b1)
    (q1 : PathP (<i> P (q @ i)) a1 b1)
    (r1 : PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
    (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
    (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
    (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
    PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1 =
  J A a (\(b : A) (p : Path A a b) -> (q : Path A a b)
          (r s : Path (Path A a b) p q)
          (t u : Path (Path (Path A a b) p q) r s)
          (v   : Path (Path (Path (Path A a b) p q) r s) t u)
          (a1 : P a) (b1 : P b)
          (p1 : PathP (<i> P (p @ i)) a1 b1)
          (q1 : PathP (<i> P (q @ i)) a1 b1)
          (r1 : PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
          (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
          (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
          (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
          PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1)
          (lem2 A P gP a)

T : U = (A : U) (P : A -> U) (gP : (x : A) -> twogroupoid (P x))
        (a b : A)
        (p q : Path A a b)
        (r s : Path (Path A a b) p q)
        (t u : Path (Path (Path A a b) p q) r s)
        (v   : Path (Path (Path (Path A a b) p q) r s) t u)
        (a1 : P a) (b1 : P b)
        (p1 : PathP (<i> P (p @ i)) a1 b1)
        (q1 : PathP (<i> P (q @ i)) a1 b1)
        (r1 : PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
        (s1 : PathP (<i> PathP (<j> P (s @ i @ j)) a1 b1) p1 q1)
        (t1 : PathP (<i> PathP (<j> PathP (<k> P (t @ i @ j @ k)) a1 b1) p1 q1) r1 s1)
        (u1 : PathP (<i> PathP (<j> PathP (<k> P (u @ i @ j @ k)) a1 b1) p1 q1) r1 s1) ->
        PathP (<i> PathP (<j> PathP (<k> PathP (<l> P (v @ i @ j @ k @ l)) a1 b1) p1 q1) r1 s1) t1 u1

g2TruncElim1 (P : T) (A : U) (B : (g2Trunc A) -> U)
             (bG : (x : g2Trunc A) -> twogroupoid (B x))
             (f : (x : A) -> B (g2inc x)) : (x : g2Trunc A) -> B x = split
  g2inc a -> f a
  g2squashC a b p q r s t u @ i j k l ->
    P (g2Trunc A) B bG a b p q r s t u
      (g2TruncTwoGroupoid A a b p q r s t u)
      (g2TruncElim1 P A B bG f a)
      (g2TruncElim1 P A B bG f b)
      (<m> g2TruncElim1 P A B bG f (p @ m))
      (<m> g2TruncElim1 P A B bG f (q @ m))
      (<m n> g2TruncElim1 P A B bG f (r @ m @ n))
      (<m n> g2TruncElim1 P A B bG f (s @ m @ n))
      (<m n o> g2TruncElim1 P A B bG f (t @ m @ n @ o))
      (<m n o> g2TruncElim1 P A B bG f (u @ m @ n @ o)) @ i @ j @ k @ l

g2TruncElim : (A : U)
              (B : (g2Trunc A) -> U)
              (bG : (x : g2Trunc A) -> twogroupoid (B x))
              (f : (x : A) -> B (g2inc x)) (x : g2Trunc A) -> B x = g2TruncElim1 lem


-- Groupoid truncation
data gTrunc (A : U) =
    ginc (a : A)
  | gsquashC (a b : gTrunc A) (p q : Path (gTrunc A) a b)
             (r s : Path (Path (gTrunc A) a b) p q) <i j k>
               [ (i=0) -> r @ j @ k
               , (i=1) -> s @ j @ k
               , (j=0) -> p @ k
               , (j=1) -> q @ k
               , (k=0) -> a
               , (k=1) -> b ]

gTruncpt (A : ptType) : ptType = (gTrunc A.1,ginc (pt A))

gTruncRec (A B : U) (bG : groupoid B) (f : A -> B) : gTrunc A -> B = split
  ginc a -> f a
  gsquashC a b p q r s @ i j k ->
    bG (gTruncRec A B bG f a)
       (gTruncRec A B bG f b)
       (<m> gTruncRec A B bG f (p @ m))
       (<m> gTruncRec A B bG f (q @ m))
       (<m n> gTruncRec A B bG f (r @ m @ n))
       (<m n> gTruncRec A B bG f (s @ m @ n)) @ i @ j @ k

gTruncGroupoid (A : U) : groupoid (gTrunc A) =
  \(a b : gTrunc A) (p q : Path (gTrunc A) a b) (r s : Path (Path (gTrunc A) a b) p q) ->
    <i j k> gsquashC{gTrunc A} a b p q r s @ i @ j @ k

-- Set truncation
data sTrunc (A : U) =
    sinc (a : A)
  | ssquashC (a b : sTrunc A) (p q : Path (sTrunc A) a b) <i j>
      [ (i=0) -> p @ j
      , (i=1) -> q @ j
      , (j=0) -> a
      , (j=1) -> b ]

sTruncpt (A : ptType) : ptType = (sTrunc A.1,sinc (pt A))

sTruncRec (A B : U) (bS : set B) (f : A -> B) : sTrunc A -> B = split
  sinc a -> f a
  ssquashC a b p q @ i j -> bS (sTruncRec A B bS f a)
                               (sTruncRec A B bS f b)
                               (<k> sTruncRec A B bS f (p @ k))
                               (<k> sTruncRec A B bS f (q @ k)) @ i @ j

setTruncSet (A : U) : set (sTrunc A) =
  \(a b : sTrunc A) (p q : Path (sTrunc A) a b) ->
    <i j> ssquashC{sTrunc A} a b p q @ i @ j

setTruncFibAux (A : U) (P : A -> U) (gP : (x : A) -> set (P x)) (a : A) :
    (q : Path A a a)
    (r : Path (Path A a a) (<_> a) q)
    (a1 b1 : P a)
    (p1 : PathP (<i> P a) a1 b1)
    (q1 : PathP (<i> P (q @ i)) a1 b1) ->
          PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1
  = J (Path A a a) (<_> a) (\ (q : Path A a a) (r : Path (Path A a a) (<_> a) q) ->
                                 (a1 b1 : P a)
                                 (p1 : PathP (<i> P a) a1 b1)
                                 (q1 : PathP (<i> P (q @ i)) a1 b1) ->
                               PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
      (\ (a1 b1 : P a) (p1 q1 : Path (P a) a1 b1) -> gP a a1 b1 p1 q1)

setTruncFib (A : U) (P : A -> U) (gP : (x : A) -> set (P x)) (a : A) :
    (b : A) (p q : Path A a b)
    (r : Path (Path A a b) p q)
    (a1 : P a) (b1 : P b)
    (p1 : PathP (<i> P (p @ i)) a1 b1)
    (q1 : PathP (<i> P (q @ i)) a1 b1) ->
    PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1 =
  J A a (\ (b : A) (p : Path A a b) -> (q : Path A a b)
          (r : Path (Path A a b) p q)
          (a1 : P a) (b1 : P b)
          (p1 : PathP (<i> P (p @ i)) a1 b1)
          (q1 : PathP (<i> P (q @ i)) a1 b1) ->
          PathP (<i> PathP (<j> P (r @ i @ j)) a1 b1) p1 q1)
          (setTruncFibAux A P gP a)

-- B.9.2  Truncated higher Hopf fibration

trS2 : U
  = g2Trunc S2
trS2Trunc : twogroupoid trS2
  = g2TruncTwoGroupoid S2

multTwoAux : (x : S2) -> Path (Path trS2 (g2inc x) (g2inc x)) (<_> g2inc x) (<_> g2inc x) = split
  base2       -> <i j> g2inc (loop2{S2} @ i @ j)
  loop2 @ k l -> setTruncFib S2 (\ (x : S2) -> Path (Path trS2 (g2inc x) (g2inc x)) (<_> g2inc x) (<_> g2inc x))
                             (\ (x : S2) (a b : Path (Path trS2 (g2inc x) (g2inc x)) (<_> g2inc x) (<_> g2inc x))
                                (p q : Path (Path (Path trS2 (g2inc x) (g2inc x)) (<_> g2inc x) (<_> g2inc x)) a b)
                                -> trS2Trunc (g2inc x) (g2inc x) (<_> g2inc x) (<_> g2inc x) a b p q)
                             base2 base2 (<_> base2) (<_> base2) (<i j> loop2{S2} @ i @ j)
                             (<i j> g2inc (loop2{S2} @ i @ j)) (<i j> g2inc (loop2{S2} @ i @ j))
                             (<_ i j> g2inc (loop2{S2} @ i @ j)) (<_ i j> g2inc (loop2{S2} @ i @ j))
                             @ k @ l

-- more direct and smaller normal form, but no noticeable performance difference
multTwoAux' : (x : S2) -> Path (Path trS2 (g2inc x) (g2inc x)) (<_> g2inc x) (<_> g2inc x) = split
  base2       -> <i j> g2inc (loop2{S2} @ i @ j)
  loop2 @ k l -> <i j>
    -- define a filler with all correct sides but one by defn, then fix the last with the truncation
    hcomp trS2
      (step1 @ k @ i @ j)
      [ (i=0) -> <_> gl @ k @ l
      , (i=1) -> <_> gl @ k @ l
      , (j=0) -> <_> gl @ k @ l
      , (j=1) -> <_> gl @ k @ l
      , (k=0) -> <_> gl @ i @ j
      , (k=1) -> <_> gl @ i @ j
      , (l=0) -> <_> gl @ i @ j
      , (l=1) -> <m>
        trS2Trunc (g2inc base2) (g2inc base2) (<_> g2inc base2) (<_> g2inc base2) gl gl
          (<k i j> step1 @ k @ i @ j) (<_ i j> gl @ i @ j)
          @ m @ k @ i @ j
      ]
    where
    gl : Path (Path trS2 (g2inc base2) (g2inc base2)) (<_> g2inc base2) (<_> g2inc base2) =
      <m n> g2inc (loop2{S2} @ m @ n)

    -- correct boundary except at l=1
    step1 : PathP (<k> Path (Path trS2 (gl @ k @ l) (gl @ k @ l)) (<_> gl @ k @ l) (<_> gl @ k @ l)) gl gl  =
      <k i j>
      hcomp trS2
        (gl @ i @ j)
        [ (i=0) -> <m> gl @ k @ l /\ m
        , (i=1) -> <m> gl @ k @ l /\ m
        , (j=0) -> <m> gl @ k @ l /\ m
        , (j=1) -> <m> gl @ k @ l /\ m
        , (k=0) -> <_> gl @ i @ j
        , (k=1) -> <_> gl @ i @ j
        , (l=0) -> <_> gl @ i @ j
        ]


multTwo : S2 -> S2 -> trS2 = split
  base2 -> (\ (x : S2) -> g2inc x)
  loop2 @ i j -> (\ (x : S2) -> multTwoAux x @ i @ j)

multTwoTilde (x : S2) : trS2 -> trS2 =
  g2TruncRec S2 trS2 trS2Trunc (multTwo x)

-- lemPropS2 (P : S2 -> U) (pP : (x : S2) -> prop (P x)) (pB : P base2) : (x : S2) -> P x = split
--     base2 -> pB
--     loop2 @ i j -> hcomp (P (loop2{S2} @ i @ j)) (lemPropF S2 P pP base2 base2 (<k> loop2{S2} @ i @ k) pB pB @ j)
--                          [ (i=0) -> <k> aux @ k @ j
--                          , (i=1) -> <k> aux @ k @ j
--                          , (j=0) -> <_> pB
--                          , (j=1) -> <_> pB ]
--                    where

--       aux : Path (Path (P base2) pB pB) (lemPropF S2 P pP base2 base2 (<_> base2) pB pB) (<_> pB) =
--         propSet (P base2) (pP base2) pB pB (lemPropF S2 P pP base2 base2 (<_> base2) pB pB) (<_> pB)

-- This needs the elimination principle for 2-groupoid truncation...
lem3Trunc (A B : U) (hB : twogroupoid B) (g h : g2Trunc A -> B)
              (H : (a : A) -> Path B (g (g2inc a)) (h (g2inc a))) :
              (x : g2Trunc A) -> Path B (g x) (h x) =
  g2TruncElim A (\(x : g2Trunc A) -> Path B (g x) (h x))
             (\(x : g2Trunc A) -> twogroupoidThreeGroupoid B hB (g x) (h x)) H

multBase2EqPath : Path (trS2 -> trS2) (\(x : trS2) -> x) (multTwoTilde base2) =
  <i> \(x : trS2) -> lem3Trunc S2 trS2 (g2TruncTwoGroupoid S2) (idfun trS2)
                               (multTwoTilde base2) (\(a : S2) -> <_> g2inc a) x @ i

multEquivBase2 : isEquiv trS2 trS2 (multTwoTilde base2) =
  subst (trS2 -> trS2) (isEquiv trS2 trS2) (idfun trS2)
        (multTwoTilde base2) multBase2EqPath (idIsEquiv trS2)

-- multTwoTildeEquiv : (x : S2) -> isEquiv trS2 trS2 (multTwoTilde x) =
--   lemPropS2
--     (\(x : S2) -> isEquiv trS2 trS2 (multTwoTilde x))
--     (\(x : S2) -> propIsEquivDirect' trS2 trS2 (multTwoTilde x))
--     multEquivBase2

opaque propIsEquivDirect'

multTwoTildeEquiv'aux : PathP (<i> PathP (<j> isEquiv trS2 trS2 (multTwoTilde (loop2 {S2} @ i @ j))) multEquivBase2 multEquivBase2) (<_> multEquivBase2) (<_> multEquivBase2) =
 <i j> hcomp (isEquiv trS2 trS2 (multTwoTilde (loop2{S2} @ i @ j)))
                              (transGen (<k> isEquiv trS2 trS2 (multTwoTilde (loop2{S2} @ (i /\ k) @ (j /\ k)))) (-i \/ -j) multEquivBase2)
                          [ (i=0) -> <l> propIsEquivDirect' trS2 trS2 (multTwoTilde base2) multEquivBase2 multEquivBase2 @ -l
                          , (i=1) -> <l> propIsEquivDirect' trS2 trS2 (multTwoTilde base2) multEquivBase2 (transGen (<k> isEquiv trS2 trS2 (multTwoTilde (loop2{S2} @ k @ (j /\ k)))) (-j) multEquivBase2) @ -l
                          , (j=0) -> <l> propIsEquivDirect' trS2 trS2 (multTwoTilde base2) multEquivBase2 multEquivBase2 @ -l
                          , (j=1) -> <l> propIsEquivDirect' trS2 trS2 (multTwoTilde base2) multEquivBase2 (transGen (<k> isEquiv trS2 trS2 (multTwoTilde (loop2{S2} @ (i /\ k) @ k))) (-i) multEquivBase2) @ -l]

transparent propIsEquivDirect'

multTwoTildeEquiv' : (x : S2) -> isEquiv trS2 trS2 (multTwoTilde x) = split
  base2 -> multEquivBase2
  loop2 @ i j -> multTwoTildeEquiv'aux @ i @ j

-- opaque multTwoTildeEquiv
-- opaque multBase2EqPath

idEquiv' : equiv trS2 trS2 = (multTwoTilde base2, multTwoTildeEquiv' base2)

-- opaque propIsEquivDirect'

tHopf3 : S3 -> U = split
  base3 -> trS2
  loop3 @ i j k ->
        Glue trS2 [ (i=0) -> (trS2, idEquiv')
                  , (i=1) -> (trS2, idEquiv')
                  , (j=0) -> (trS2, idEquiv')
                  , (j=1) -> (trS2, idEquiv')
                  , (k=0) -> (trS2, (multTwoTilde (loop2{S2} @ i @ j),multTwoTildeEquiv' (loop2{S2} @ i @ j)))
                  , (k=1) -> (trS2, idEquiv')]

pi3S3 (p : (Omega3 S3pt).1) : (Omega2 (g2Truncpt S2pt)).1 =
  <i j> transGen (<k> tHopf3 (p @ j @ k @ i)) 0 (g2inc base2) 
  -- mapOmegaRefl2 (Omega S3pt) trS2 pi3S3'
  --   where
  --   pi3S3' (p : (Omega S3pt).1) : trS2 =
  --     subst S3 tHopf3 base3 base3 p (g2inc base2)

----------------------------------
-- B.10 Loop spaces of truncations

substTrans (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

transEquiv' (A X : U) (p : Path U X A) : equiv X A =
  substTrans U (\(Y : U) -> equiv Y A) A X (<i> p @ -i) (idEquiv A)

uaRetraction (A X : U) (p : Path U X A) : Path (Path U X A) (ua X A (transEquiv' A X p)) p =
  <j i>
  Glue A
    [ (i=0) -> (X, transEquiv' A X p)
    , (i=1) -> (A, idEquiv A)
    , (j=1) -> (p @ i, transGen (<k> equiv (p @ -k \/ i) A) i (idEquiv A))
    ]

lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = <i> (p @ i,sq1 @ i)
  where
    rem0 : Path A (g y) x0 =
      <i> hcomp A (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem1 : Path A (g y) x1 =
      <i> hcomp A (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    p : Path A x0 x1 =
     <i> hcomp A (g y) [ (i = 0) -> rem0
                            , (i = 1) -> rem1 ]

    fill0 : Square A (g y) (g (f x0)) (g y) x0
                     (<i> g (p0 @ i)) rem0 (<i> g y) (t x0)  =
      <i j> hcomp A (g (p0 @ i)) [ (i = 1) -> <k> t x0 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p0 @ i) ]

    fill1 : Square A (g y) (g (f x1)) (g y) x1
                     (<i> g (p1 @ i)) rem1 (<i> g y) (t x1) =
      <i j> hcomp A (g (p1 @ i)) [ (i = 1) -> <k> t x1 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p1 @ i) ]

    fill2 : Square A (g y) (g y) x0 x1
                     (<k> g y) p rem0 rem1 =
      <i j> hcomp A (g y) [ (i = 0) -> <k> rem0 @ j /\ k
                               , (i = 1) -> <k> rem1 @ j /\ k
                               , (j = 0) -> <k> g y ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
                  (<i> g y) (<i> g (f (p @ i)))
                  (<j> g (p0 @ j)) (<j> g (p1 @ j)) =
      <i j> hcomp A (fill2 @ i @ j) [ (i = 0) -> <k> fill0 @ j @ -k
                                         , (i = 1) -> <k> fill1 @ j @ -k
                                         , (j = 0) -> <k> g y
                                         , (j = 1) -> <k> t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
                   (<k>y) (<i> f (p @ i)) p0 p1 =
      <i j> hcomp B (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j)
                                         , (i = 1) -> s (p1 @ j)
                                         , (j = 1) -> s (f (p @ i))
                                         , (j = 0) -> s y ]

gradLemma (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
  \(y:B) -> ((g y,<i>s y@-i),\ (z:fiber A B f y) ->
    lemIso A B f g s t y (g y) z.1 (<i>s y@-i) z.2)

isoPath (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Path B (f (g y)) y)
      (t : (x : A) -> Path A (g (f x)) x) : Path U A B =
       <i> Glue B [ (i = 0) -> (A,f,gradLemma A B f g s t)
                  , (i = 1) -> (B,idfun B,idIsEquiv B) ]

pi (A:U) (P:A->U) : U = (x:A) -> P x

setPi (A:U) (B:A -> U) (h:(x:A) -> set (B x)) (f g : pi A B) : prop (Path (pi A B) f g) =
  \(p q : Path (pi A B) f g) ->
  <j i> \(a : A) -> h a (f a) (g a) (<i> p @ i a) (<i> q @ i a) @ j @ i

setSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> prop (Path A t.1 u.1)) (t u : Sigma A B)
  : prop (Path (Sigma A B) t u) =
  retractProp T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

-- second verse, same as the first
groupoidSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> set (Path A t.1 u.1)) (t u : Sigma A B)
  : set (Path (Sigma A B) t u) =
  retractSet T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

-- third verse, similar to the first two
twogroupoidSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> groupoid (Path A t.1 u.1)) (t u : Sigma A B)
  : groupoid (Path (Sigma A B) t u) =
  retractGroupoid T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

groupoidPi (A : U) (B : A -> U) (h : (x : A) -> groupoid (B x)) (f g : pi A B) : set (Path (pi A B) f g) =
  \(p q : Path (pi A B) f g) ->
  \(r s : Path (Path (pi A B) f g) p q) ->
  <k j i> \(a : A) ->
  h a (f a) (g a) (<i> p @ i a) (<i> q @ i a) (<j i> r @ j @ i a) (<j i> s @ j @ i a) @ k @ j @ i

groupoidFun (A B : U) (sB : groupoid B) : groupoid (A -> B) =
  groupoidPi A (\(x : A) -> B) (\(x : A) -> sB)

groupoidPath (A B : U) (sB : groupoid B) : groupoid (Path U A B) =
  retractGroupoid (Path U A B) (equiv A B) (transEquiv' B A) (ua A B) (uaRetraction B A) rem
  where
  rem : groupoid (equiv A B) =
    groupoidSigProp (A -> B) (isEquiv A B) (propIsEquivDirect' A B)
      (\(E F : equiv A B) -> groupoidFun A B sB E.1 F.1)

twogroupoidGROUPOID : twogroupoid GROUPOID =
  twogroupoidSigProp U groupoid groupoidIsProp (\(A B : GROUPOID) -> groupoidPath A.1 B.1 B.2)

-- opaque twogroupoidGROUPOID

truncPath2 : g2Trunc S2 -> GROUPOID =
  g2TruncRec S2 GROUPOID twogroupoidGROUPOID
    (\(x : S2) -> (gTrunc (Path S2 base2 x),gTruncGroupoid (Path S2 base2 x)))

kappaTwo (p : (Omega (g2Truncpt S2pt)).1) : gTrunc (Omega S2pt).1 =
  transGen (<i> (truncPath2 (p @ i)).1) 0 (ginc (<_> base2))
-- subst (g2Trunc A.1) (\(x : g2Trunc A.1) -> (truncPath2 A x).1)
--         (g2inc (pt A)) (g2inc (pt A)) p (ginc (<_> pt A))

-- kappaTwoPt (A : ptType) :
--   Path (gTrunc (Omega A).1)
--     (kappaTwo A (pt (Omega (g2Truncpt A))))
--     (pt (gTruncpt (Omega A))) =
--     <i> transGen (<_> (truncPath2 A (pt (g2Truncpt A))).1) i (ginc (<_> pt A))

-- Groupoid set
setFun (A B : U) (sB : set B) : set (A -> B) =
 setPi A (\(x : A) -> B) (\(x : A) -> sB)

setPath (A B : U) (sB : set B) : set (Path U A B) =
  retractSet (Path U A B) (equiv A B) (transEquiv' B A) (ua A B) (uaRetraction B A) rem
  where
  rem : set (equiv A B) =
    setSigProp (A -> B) (isEquiv A B) (propIsEquivDirect' A B)
      (\(E F : equiv A B) -> setFun A B sB E.1 F.1)

groupoidSET : groupoid SET =
  groupoidSigProp U set setIsProp (\(A B : SET) -> setPath A.1 B.1 B.2)

-- opaque groupoidSET

truncPath1 (A : ptType) : gTrunc A.1 -> SET =
  gTruncRec A.1 SET groupoidSET
    (\(x : A.1) -> (sTrunc (Path A.1 (pt A) x),setTruncSet (Path A.1 (pt A) x)))

kappaOne (A : ptType) (p : (Omega (gTruncpt A)).1) : sTrunc (Omega A).1 =
  subst (gTrunc A.1) (\(x : gTrunc A.1) -> (truncPath1 A x).1)
        (ginc (pt A)) (ginc (pt A)) p (sinc (<_> pt A))



--------------------------------------------------------------------------------
-- B.11 Down one more dimension

-- e'_2 from 12
pi2S2' (p : (Omega2 S2pt).1) : loopS1 =
  <i> transGen (<j> Hopf (p @ j @ i)) 0 base1
  -- let point : (Omega S2pt).1 = pt (Omega S2pt)
  -- in subst (Omega S2pt).1 HopfOne point point p (<_> base1)

e2' : sTrunc (Omega2 S2pt).1 -> loopS1 =
  sTruncRec (Omega2 S2pt).1 loopS1 setLoop pi2S2'

-- experiment with alternative definitions in place of f8-11. seems much faster.

codeS2 (s : S2) : GROUPOID = (gTrunc (Hopf s), gTruncGroupoid (Hopf s))

codeTruncS2 : g2Trunc S2 -> GROUPOID = g2TruncRec S2 GROUPOID twogroupoidGROUPOID codeS2

encodeTruncS2 (p : (Omega (g2Truncpt S2pt)).1) : gTrunc S1 = transGen (<i> (codeTruncS2 (p @ i)).1) 0 (ginc base1)

codeS1 (s : S1) : SET = (sTrunc (helix s), setTruncSet (helix s))

codeTruncS1 : gTrunc S1 -> SET = gTruncRec S1 SET groupoidSET codeS1

encodeS1 (p : (Omega (gTruncpt S1pt)).1) : sTrunc Z = transGen (<i> (codeTruncS1 (p @ i)).1) 0 (sinc (pos zero))

-- g8-10 replaces f8-11

g8 : (Omega2 (g2Truncpt S2pt)).1 -> (Omega (gTruncpt S1pt)).1 =
  mapOmegaRefl (Omega (g2Truncpt S2pt)) (gTrunc S1) encodeTruncS2

g9 : (Omega (gTruncpt S1pt)).1 -> sTrunc Z = encodeS1

g10 : sTrunc Z -> Z = sTruncRec Z Z ZSet (idfun Z)

-- end of experiment

--- tests

test0To2 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ i @ j @ k

f3 : (Omega3 S3pt).1 -> (Omega3 (joinpt S1pt S1)).1 =
  mapOmegaRefl3 S3pt (join S1 S1) e

test0To3 : (Omega3 (joinpt S1pt S1)).1 = f3 test0To2

f4 : (Omega3 (joinpt S1pt S1)).1 -> (Omega3 S2pt).1 =
  mapOmegaRefl3 (joinpt S1pt S1) S2 alpha

test0To4 : (Omega3 S2pt).1 = f4 test0To3

-- Rotating test0To4 seems to make both fibContrHopfThree' and
-- fibContrHopfThree'' compute a lot faster and with smaller result.

test0To4_rotijk : (Omega3 S2pt).1 = <i j k> test0To4 @ i @ j @ k
test0To4_rotikj : (Omega3 S2pt).1 = <i j k> test0To4 @ i @ k @ j
test0To4_rotjik : (Omega3 S2pt).1 = <i j k> test0To4 @ j @ i @ k
test0To4_rotjki : (Omega3 S2pt).1 = <i j k> test0To4 @ j @ k @ i
test0To4_rotkij : (Omega3 S2pt).1 = <i j k> test0To4 @ k @ i @ j
test0To4_rotkji : (Omega3 S2pt).1 = <i j k> test0To4 @ k @ j @ i


{- Benchmarks:

fibContrHopfThree'    #hcomps        Time
test0To4_rotijk       1364053      1m50.877s
test0To4_rotikj        165103      0m10.991s
test0To4_rotjik       1364053      2m2.726s
test0To4_rotjki        165103      0m5.603s
test0To4_rotkij        294803      0m17.040s
test0To4_rotkji        294803      0m13.404s

fibContrHopfThree''
test0To4_rotijk       1519518      2m0.453s
test0To4_rotikj        148813      0m6.695s
test0To4_rotjik       1535957      2m10.983s
test0To4_rotjki        149430      0m6.048s
test0To4_rotkij        541426      0m20.965s
test0To4_rotkji        540654      0m20.687s


The fastest rotation hence seems to be test0To4_rotikj... WHY?

-}

{- Benchmarks for fibContrHopfThree_unprime (Guillaume's desktop computer, September 25):

fCHT_unprime          #hcomps        Time
test0To4_rotijk            (untested)
test0To4_rotikj       1394791      1m11.536s
test0To4_rotjik            (untested)
test0To4_rotjki       1402633      1m7.649s
test0To4_rotkij            (untested)
test0To4_rotkji            (doesn't terminate within two hours)

-}

-- Alternative version computed using goalcube'. This is wrong, but useful for benchmarks
test0To4_goalcube' : (Omega3 S2pt).1 =
  <i j k> hcomp S2 (hcomp S2 (hcomp S2 (loop2 {S2} @ j @ k) [(k=0) -> <_> base2
                                                            ,(k=1) -> <l> loop2 {S2} @ i @ l])
                             [(i=0) -> <l> hcomp S2 (loop2 {S2} @ (j /\ -l) @ k)
                                                        [(k=0) -> <_> base2
                                                        ,(k=1) -> <_> base2 ]
                             ,(i=1) -> <l> hcomp S2 (loop2 {S2 } @ (j /\ -l) @ k)
                                                        [(k=0) -> <_> base2
                                                        ,(k=1) -> <m> loop2 {S2} @ -l @ m]
                             ,(j=0) -> <l> hcomp S2 base2
                                                         [(k=0) -> <_> base2
                                                         ,(k=1) -> <m> loop2 {S2} @ (i /\ -l) @ m]
                             ,(j=1) -> <l> hcomp S2 (loop2 {S2} @ -l @ k)
                                                        [(k=0) -> <_> base2
                                                        ,(k=1) -> <m> loop2 {S2} @ (i /\ -l) @ m]
                             ,(k=0) -> <l> base2
                             ,(k=1) -> <l> base2 ])
                   [(i=0) -> <l> hcomp S2 base2 [(k=0) -> <_> base2,(k=1)(l=0) -> <_> base2,(l=1) -> <_> base2 ]
                   ,(i=1) -> <l> hcomp S2 base2 [(k=0) -> <_> base2,(k=1)(l=0) -> <_> base2,(l=1) -> <_> base2 ]
                   ,(j=0) -> <l> hcomp S2 base2 [(k=0) -> <_> base2,(k=1)(l=0) -> <_> base2,(l=1) -> <_> base2 ]
                   ,(j=1) -> <l> hcomp S2 base2 [(k=0) -> <_> base2,(k=1)(l=0) -> <_> base2,(l=1) -> <_> base2 ]
                   ,(k=0) -> <l> base2
                   ,(k=1) -> <l> hcomp S2 base2 [(l=0) -> <_> base2, (l=1) -> <_> base2 ]]

-- Part of test0To5
-- testFibContrHopf3 : HopfThree' test0To4 = fibContrHopfThree' test0To4
testFibContrHopf3refl : HopfThree' (<_ _ _> base2) = fibContrHopfThree' (<_ _ _> base2)

foo : (Omega3 S2pt).1 = <i j k> hcomp S2 base2 [ (i=0) -> <l> loop2{S2} @ l @ l
                                               , (i=1) -> <l> loop2{S2} @ l @ l
                                               , (j=0) -> <l> loop2{S2} @ l @ l
                                               , (j=1) -> <l> loop2{S2} @ l @ l
                                               , (k=0) -> <l> loop2{S2} @ l @ l
                                               , (k=1) -> <l> loop2{S2} @ l @ l
                                               ]
                                               
testFibContrHopf3foo : HopfThree' foo = fibContrHopfThree' foo

f5 : (Omega3 S2pt).1 -> (Omega3 (joinpt S1pt S1)).1 = h

test0To5 : (Omega3 (joinpt S1pt S1)).1 = f5 test0To4

f5' : (Omega3 S2pt).1 -> (Omega3 (joinpt S1pt S1)).1 = h'

test0To5' : (Omega3 (joinpt S1pt S1)).1 = f5' test0To4

f6 : (Omega3 (joinpt S1pt S1)).1 -> (Omega3 S3pt).1 =
  mapOmegaRefl3 (joinpt S1pt S1) S3 eInv

test0To6 : (Omega3 S3pt).1 = f6 test0To5

f7 : (Omega3 S3pt).1 -> (Omega2 (g2Truncpt S2pt)).1 = pi3S3

test0To7 : (Omega2 (g2Truncpt S2pt)).1 = f7 test0To6

f8 (p : (Omega2 (g2Truncpt S2pt)).1) : (Omega (gTruncpt (Omega S2pt))).1 =
 -- (mapOmega (Omega (g2Truncpt S2pt)) (gTruncpt (Omega S2pt)) (kappaTwo S2pt, kappaTwoPt S2pt)).1
 <i> hcomp (gTrunc (Path S2 base2 base2)) (kappaTwo (p @ i))
           [ (i=0) -> <j> ginc (<k> hcomp S2 base2 [(k=0) -> <_> base2, (k=1) -> <_> base2, (j=1) -> <_> base2])
           , (i=1) -> <j> ginc (<k> hcomp S2 base2 [(k=0) -> <_> base2, (k=1) -> <_> base2, (j=1) -> <_> base2]) ]

test0To8 : (Omega (gTruncpt (Omega S2pt))).1 = f8 test0To7

f9 : (Omega (gTruncpt (Omega S2pt))).1 -> sTrunc (Omega2 S2pt).1 =
  kappaOne (Omega S2pt)

test0To9 : sTrunc (Omega2 S2pt).1 = f9 test0To8

f10 : sTrunc (Omega2 S2pt).1 -> loopS1 = e2'

test0To10 : loopS1 = f10 test0To9

f11 : loopS1 -> Z = encode base1

brunerie : Z = f11 test0To10

-- More versions
brunerie_rotijk : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotijk))))))
brunerie_rotikj : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotikj))))))
brunerie_rotjik : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotjik))))))
brunerie_rotjki : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotjki))))))
brunerie_rotkij : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotkij))))))
brunerie_rotkji : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5 test0To4_rotkji))))))


-- Versions of brunerie that might be faster, uses h' (so
-- fibContrHopfThree_unfolded)

brunerie_rotijk' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotijk))))))
brunerie_rotikj' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotikj))))))
brunerie_rotjik' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotjik))))))
brunerie_rotjki' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotjki))))))
brunerie_rotkij' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotkij))))))
brunerie_rotkji' : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotkji))))))

-- This is potentially the fastest?
brunerie_opt : Z = f11 (f10 (f9 (f8 (f7 (f6 (f5' test0To4_rotjki))))))



test631' : Z = g10 (g9 (g8 (f7 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 test0To2)))))))))))))))))))))))
testShortcut4To5' : Z = g10 (g9 (g8 (f7 (f6 (f3 test0To2)))))

-- Try to compute some shortcuts and various experiments

-- Skips the maps e, alpha, h and eInv
-- Now terminates very quickly.
testShortcut3To6 : Z = f11 (f10 (f9 (f8 (f7 test0To2))))

-- Skips the maps alpha and h
testShortcut4To5 : Z = f11 (f10 (f9 (f8 (f7 (f6 (f3 test0To2))))))

-- Make input to the latter maps bigger by going back and forth between f6 and f3
test631 : Z = f11 (f10 (f9 (f8 (f7 (f6 (f3 (f6 (f3 test0To2))))))))
test632 : Z = f11 (f10 (f9 (f8 (f7 (f6 (f3 (f6 (f3 (f6 (f3 test0To2))))))))))

-- uses too much memory
test633 : Z = f11 (f10 (f9 (f8 (f7 (f6 (f3 (f6 (f3 (f6 (f3 (f6 (f3 test0To2))))))))))))

-- Here are some tests to investigate why [testShortcut4To5] takes so much memory:
abc0 : (Omega3 S3pt).1 = <i j k> hcomp S3 (loop3{S3} @ j @ k @ i)
                              [ (i = 0) -> <_> base3
                              , (i = 1) -> <_> base3
                              , (j = 0) -> <_> base3
                              , (j = 1) -> <_> base3
                              , (k = 0) -> <_> base3
                              , (k = 1) -> <_> base3 ]

abc0' : (Omega3 S3pt).1 = <i j k> hcomp S3 (loop3{S3} @ j @ k @ i)
                              [ (i = 0) -> <l> hcomp S3 base3
                                             [(j=0) -> <_> base3 ,
                                              (j=1) -> <_> base3 ,
                                              (l=0) -> <_> base3 ,
                                              (l=1) -> <_> base3 ,
                                              (k=1) -> <_> base3 ]
                              , (i = 1) -> <_> base3
                              , (j = 0) -> <_> base3
                              , (j = 1) -> <_> base3
                              , (k = 0) -> <l> hcomp S3 base3
                                             [(j=0) -> <_> base3 ,
                                              (j=1) -> <_> base3 ,
                                              (l=0) -> <_> base3 ,
                                              (l=1) -> <_> base3 ,
                                              (i=1) -> <_> base3 ]
                              , (k = 1) -> <_> base3 ]

abc1 : (Omega3 S3pt).1 = <i j k> hcomp S3 base3
                              [ (i = 0) -> <l> loop3{S3} @ j @ k @ l
                              , (i = 1) -> <_> base3
                              , (j = 0) -> <_> base3
                              , (j = 1) -> <_> base3
                              , (k = 0) -> <_> base3
                              , (k = 1) -> <_> base3 ]

abc2 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ i @ j @ k
abc3 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ i @ k @ j
abc4 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ j @ i @ k
abc5 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ j @ k @ i
abc6 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ k @ i @ j
abc7 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ k @ j @ i

abc8 : (Omega2 S2pt).1 = <i j> loop2{S2} @ j @ i
abc9 : (Omega2 S2pt).1 = <i j> loop2{S2} @ i @ j

F : (Omega3 S3pt).1 -> Z = \ (x : (Omega3 S3pt).1) -> f11 (f10 (f9 (f8 (f7 x))))

-- <i j k> hcomp S3 (loop3 {S3} @ j @ k @ i)
--                  [(i=0) -> <l> hcomp S3 base3
--                                              [(j=0) -> <_> base3 ,
--                                               (j=1) -> <_> base3 ,
--                                               (l=0) -> <_> base3 ,
--                                               (l=1) -> <_> base3 ],
--                   (i=1) -> <l> base3 ,
--                   (j=0) -> <l> base3 ,
--                   (j=1) -> <l> base3 ,
--                   (k=0) -> <l> hcomp S3 base3
--                                              [(i=1) -> <_> base3 ,
--                                               (j=0) -> <_> base3 ,
--                                               (j=1) -> <_> base3 ,
--                                               (l=0) -> <_> base3 ,
--                                               (l=1) -> <_> base3 ],
--                   (k=1) -> <l> hcomp S3 base3
--                                              [(i=1) -> <_> base3 ,
--                                               (j=0) -> <_> base3 ,
--                                               (j=1) -> <_> base3 ,
--                                               (l=0) -> <_> base3 ,
--                                               (l=1) -> <_> base3 ]]
-- Doesnt contain too many hcomps
testabc0 : (Omega (gTruncpt (Omega S2pt))).1 = f8 (f7 abc0)

-- Contains about 170000 hcomps (essentially all of them composing reflexivities)
testabc1 : (Omega (gTruncpt (Omega S2pt))).1 = f8 (f7 abc1)

-- Fast and small (like testabc0)
testabc2 : Z = f11 (f10 (f9 (f8 (f7 abc2))))

-- Slow and big (like testabc1)
testabc3 : Z = f11 (f10 (f9 (f8 (f7 abc3))))


-- Various simple tests:
testShortcutf11 : Z = f11 (f10 (sinc (<i j> loop2{S2} @ i @ j)))
testShortcutf11' : Z = f11 (f10 (f9 (<i> ginc (<j> loop2{S2} @ i @ j))))
testShortcutf11'' : Z = f11 (f10 (f9 (f8 (<i j> g2inc (loop2{S2} @ i @ j)))))

itestShortcutf11 : Z = f11 (f10 (sinc (<i j> loop2{S2} @ j @ i)))
itestShortcutf11' : Z = f11 (f10 (f9 (<i> ginc (<j> loop2{S2} @ j @ i))))
itestShortcutf11'' : Z = f11 (f10 (f9 (f8 (<i j> g2inc (loop2{S2} @ j @ i)))))
 
innerpath :
  PathP (<j> Path S1
                 (transGen (<k> Hopf (test0To4 @ 0 @ j @ k)) 0 base1)
                 (transGen (<k> Hopf (test0To4 @ 1 @ j @ k)) 0 base1))
        (<j> transGen (<k> Hopf (test0To4 @ 0 @ j @ k)) 0 base1)
        (<j> transGen (<k> Hopf (test0To4 @ 1 @ j @ k)) 0 base1) =
  <i j> transGen (<k> Hopf (test0To4 @ i @ j @ k)) 0 base1

-- This path does not terminate. The innermost transGen does though
problem : Path Z (pos zero) (pos zero) =
  <i> transGen (<j> helix (innerpath @ i @ j)) 0 (pos zero)

-- This term contains a ton of hcomp U:
problempath : Path U (helix (transGen (<k> Hopf (test0To4 @ k @ 0 @ k)) 0 base1))
                     (helix (transGen (<k> Hopf (test0To4 @ k @ 1 @ k)) 0 base1)) =
              <j> helix (transGen (<k> Hopf (test0To4 @ k @ j @ k)) 0 base1)

