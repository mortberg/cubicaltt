module nat where

import hedberg
import bool

data nat = zero | suc (n : nat)

one : nat = suc zero
two : nat = suc one

pred : nat -> nat = split
  zero -> zero
  suc n -> n

add (m : nat) : nat -> nat = split
  zero  -> m
  suc n -> suc (add m n)

add_zero : (n : nat) -> Id nat (add zero n) n = split
  zero  -> <i> zero
  suc n -> <i> suc (add_zero n @ i)

add_suc (a:nat) : (n : nat) -> Id nat (add (suc a) n) (suc (add a n)) = split
  zero  ->  <i> suc a
  suc m -> <i> suc (add_suc a m @ i)

add_comm (a : nat) : (n : nat) -> Id nat (add a n) (add n a) = split
  zero  -> <i> add_zero a @ -i
  suc m -> <i> comp (<_> nat) (suc (add_comm a m @ i))
                    [ (i = 0) -> <j> suc (add a m)
                    , (i = 1) -> <j> add_suc m a @ -j ]

assocAdd (a b:nat) : (c:nat) -> Id nat (add a (add b c)) (add (add a b) c) = split
 zero -> <i>add a b
 suc c1 -> <i>suc (assocAdd a b c1@i)

add' : nat -> nat -> nat = split
  zero -> \(x : nat) -> x
  suc n -> \(x : nat) -> suc (add' n x)

sucInj (n m : nat) (p : Id nat (suc n) (suc m)) : Id nat n m =
 <i> pred (p @ i)

add_comm3 (a b c : nat) : Id nat (add a (add b c)) (add c (add b a)) =
  let rem : Id nat (add a (add b c)) (add a (add c b)) = <i> add a (add_comm b c @ i)
      rem1 : Id nat (add a (add c b)) (add (add c b) a) = add_comm a (add c b)
      rem2 : Id nat (add (add c b) a) (add c (add b a)) = <i> assocAdd c b a @ -i
  in <i> comp (<_> nat) (rem1 @ i) [ (i = 0) -> <j> rem @ -j, (i = 1) -> rem2 ]

natcancelr (a b : nat) : (x : nat) -> Id nat (add a x) (add b x) -> Id nat a b = split
  zero -> \(h : Id nat a b) -> h
  suc x' -> \(h : Id nat (suc (add a x')) (suc (add b x'))) ->
    natcancelr a b x' (sucInj (add a x') (add b x') h)

idnat : nat -> nat = split
  zero -> zero
  suc n -> suc (idnat n)

test : Id (nat -> nat) idnat (idfun nat) = funExt nat (\(_ : nat) -> nat) idnat (idfun nat) rem
  where
  rem : (n : nat) -> Id nat (idnat n) n = split
    zero -> refl nat zero
    suc n -> mapOnPath nat nat (\(x : nat) -> suc x) (idnat n) n (rem n)

caseNat (A : U) (a0 aS : A) : nat -> A = split
 zero -> a0
 suc n -> aS

caseDNat (P:nat -> U) (a0 :P zero) (aS : (n:nat) -> P (suc n))
            : (n:nat) -> P n = split
 zero -> a0
 suc n -> aS n

znots (n : nat) : neg (Id nat zero (suc n)) =
 \ (h:Id nat zero (suc n)) -> subst nat (caseNat U nat N0) zero (suc n) h zero

snotz (n : nat) : neg (Id nat (suc n) zero) =
 \ (h:Id nat (suc n) zero) -> znots n (inv nat (suc n) zero h)

natDec : (n m:nat) -> dec (Id nat n m) = split
 zero -> caseDNat (\ (m:nat) -> dec (Id nat zero m)) (inl (refl nat zero)) (\ (m:nat) -> inr (znots m))
 suc n -> caseDNat (\ (m:nat) -> dec (Id nat (suc n) m)) (inr (snotz n))
   (\ (m:nat) -> decEqCong (Id nat n m) (Id nat (suc n) (suc m)) (\ (p:Id nat n m) -> <i> suc (p @ i))
                 (sucInj n m) (natDec n m))

natSet : set nat = hedberg nat natDec

equalNat : nat -> nat -> bool = split
    zero -> split@(nat -> bool) with
      zero  -> true
      suc n -> false
    suc m -> split@(nat -> bool) with
      zero  -> false
      suc n -> equalNat m n
