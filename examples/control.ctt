module control where

import prelude

-- Recursion/Corecursion

data fix (F: U -> U) = Fix (point: F (fix F))

out_ (F: U -> U): fix F -> F (fix F) = split Fix f -> f
in_  (F: U -> U): F (fix F) -> fix F = \(x: F (fix F)) -> Fix x

data freeF   (F: U -> U) (A B: U)  = ReturnF (a: A) | BindF (f: F B)
data cofreeF (F: U -> U) (A B: U)  = CoBindF (a: A)         (f: F B)
data free    (F: U -> U) (A: U)    = Free    (_: fix (freeF     F A))
data cofree  (F: U -> U) (A: U)    = CoFree  (_: fix (cofreeF   F A))

unfree   (A: U) (F: U -> U): free   F A -> fix (freeF   F A) = split Free   a -> a
uncofree (A: U) (F: U -> U): cofree F A -> fix (cofreeF F A) = split CoFree a -> a

-- Control Type-Classes

pure (A: U) (F: U -> U): U
    = (return: A -> F A)
    * Unit

o (A B C: U) (f: B -> C) (g: A -> B): A -> C = \(x:A) -> f (g x)

functor_ (A B: U) (F: U -> U): U
    = (fmap: (A -> B) -> F A -> F B) * Unit

functor (F: U -> U): U
    = (fmap: (A B: U) -> (A -> B) -> F A -> F B)
    * (id: (A: U) -> (x: F A) -> Path (F A) (fmap A A (idfun A) x) x)
    * (compose: (A B C: U) (f: B -> C) (g: A -> B) (x: F A) ->
      Path (F C) (fmap A C (o A B C f g) x)
                 ((o (F A) (F B) (F C) (fmap B C f) (fmap A B g)) x)) * Unit

applicative (A B: U) (F: U -> U): U
    = (pure_: pure A F)
    * (functor_: functor_ A B F)
    * (ap: F (A -> B) -> F A -> F B)
    * Unit

monad (A B: U) (F: U -> U): U
    = (pure_: pure A F)
    * (functor_: functor F)
    * (join: F (F A) -> F B)
    * Unit

comonad (A B: U) (F: U -> U): U
    = (pure_: pure A F)
    * (functor_: functor F)
    * (extract: F A -> A)
    * (duplicate: F A -> F (F A))
    * (extend: (F A -> B) -> F A -> F B)
    * Unit
