-- Propositional truncation as a HIT.
module propTrunc where

import bool
import sigma
import pi
import univalence

data pTrunc (A : U)
  = inc (a : A)
  | inh (x y : pTrunc A) <i> [(i=0) -> x, (i=1) -> y]

pTruncIsProp (A : U) : prop (pTrunc A) =
 \ (x y : pTrunc A) -> <i> inh{pTrunc A} x y @ i

pTruncRec (A B : U) (pP : prop B) (f : A -> B) : pTrunc A -> B = split
  inc a -> f a
  inh x y @ i -> pP (pTruncRec A B pP f x) (pTruncRec A B pP f y) @ i

pTruncElim (A : U) (B : (pTrunc A) -> U)
           (pP : (x : pTrunc A) -> prop (B x))
           (f : (a : A) -> B (inc a))
           : (x : pTrunc A) -> B x = split
  inc a -> f a
  inh x y @ i ->
    lemPropF (pTrunc A) B pP x y
      (<j> inh{pTrunc A} x y @ j)
      (pTruncElim A B pP f x)
      (pTruncElim A B pP f y)
    @ i


-- test with truncation of unit

tU : U = pTrunc Unit

test : prop Unit = split@((x y : Unit) -> Path Unit x y) with
    tt -> split@((y : Unit) -> Path Unit tt y) with
      tt -> <i> tt

f1 : tU -> Unit = split
  inc a -> a
  inh x y @ i -> propUnit (f1 x) (f1 y) @ i

f2 : Unit -> tU = \(x : Unit) -> inc x

-- TODO: upstream the following 3 things
hProp : U = (X : U) * prop X

subtypeEquality (A : U) (B : A -> U) (pB : (x : A) -> prop (B x))
                (s t : (x : A) * B x) : Path A s.1 t.1 -> Path (Sigma A B) s t =
  trans (Path A s.1 t.1) (Path (Sigma A B) s t) rem
    where
    rem : Path U (Path A s.1 t.1) (Path (Sigma A B) s t) =
      <i> lemSigProp A B pB s t @ -i

uahp (P P' : hProp) (f : P.1 -> P'.1) (g : P'.1 -> P.1) : Path hProp P P' =
  subtypeEquality U prop propIsProp P P' rem
  where
  rem : Path U P.1 P'.1 = isoPath P.1 P'.1 f g s t
    where s (y : P'.1) : Path P'.1 (f (g y)) y = P'.2 (f (g y)) y
          t (x : P.1) : Path P.1 (g (f x)) x = P.2 (g (f x)) x

foo : Path U tU Unit =
  <i> (uahp (tU,pTruncIsProp Unit) (Unit,propUnit) f1 f2 @ i).1

test1 : Unit = transport foo (inc tt)
test2 : tU = transport (<i> foo @ -i) tt
